<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Map的排序方式</title>
      <link href="/2018/08/29/Map%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/29/Map%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>在对Map排序时学到了一种新的排序方式，那就是利用Map.Entry类和Collections.sort()方法排序。通过Map.Entry类创建一个Map对应的ArrayList,把”对Map排序”问题转化为”对Collection排序”.<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">参考链接</a></p><hr><h3 id="1-实例"><a href="#1-实例" class="headerlink" title="1. 实例"></a>1. 实例</h3><p>在《Java编程思想（第四版）》持有对象这一章中，有这样一个题，要求按照值对Map排序：</p><blockquote><p>26.拿到前一个练习中所产生的Map,并按照它们在最初的文件中出现的顺序重新创建单词顺序.</p></blockquote><p>前一个题为:</p><blockquote><p>25.创建一个Map&lt;String,List<integer>&gt;,使用net.mindview.TextFile来打开一个文本文件,并一次读入一个单词(用”\W+”作为TextFile构造器的第二个参数).在读入单词时对它们进行计数,并且对于文件中的每一个单词,都在List<integer>中记录下与这个词相关联的单词计数.实际上,它记录的是该单词在文件中被发现的位置.</integer></integer></p></blockquote><p>这样看来就是要创建一个Map&lt;String,List<integer>&gt;,然后依据List<integer>的第一项对Map排序.第25题代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> net.mindview.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackEx1125</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=<span class="keyword">new</span> LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">new</span> TextFile(<span class="string">"SetOperations.java"</span>,<span class="string">"\\W+"</span>));</span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> TreeSet&lt;String&gt;(list);</span><br><span class="line"><span class="keyword">for</span>(String x:set)&#123;</span><br><span class="line">ArrayList&lt;Integer&gt;ar=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x.equals(list.get(i)))&#123;</span><br><span class="line">ar.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">map.put(x,ar);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(map);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></integer></p><p>要在这个基础上以Map的值(List<integer>)的第一项为依据排序,使用Map.Entry类和Collections.sort()方法排序的话就需要:</integer></p><ol><li><p>创建一个List&lt;Map.Entry&lt;String,List<integer>&gt;&gt; list:</integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt; list1=<span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;(map.entrySet());</span><br></pre></td></tr></table></figure></li><li><p>用Collections.sort()对list排序(重写其compare()方法);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list1,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)</span></span>&#123;</span><br><span class="line">ArrayList ar1=(ArrayList)o1.getValue();</span><br><span class="line">ArrayList ar2=(ArrayList)o2.getValue();</span><br><span class="line">Integer aar1=(Integer)ar1.get(<span class="number">0</span>);</span><br><span class="line">Integer aar2=(Integer)ar2.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> aar1.compareTo(aar2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建新的LinkedHashMap&lt;String,List<integer>&gt;以储存排序后的Map:</integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,ArrayList&lt;Integer&gt;&gt;sortMap=<span class="keyword">new</span> LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; mapping:list1)&#123;</span><br><span class="line">ArrayList ar3=(ArrayList)mapping.getValue();</span><br><span class="line">sortMap.put(mapping.getKey(),ar3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>完整程序为:</p><pre><code>import net.mindview.util.*;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.TreeMap;import java.util.*;public class BackEx1126{    public static void main(String[] args){        Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;();        List&lt;String&gt; list=new ArrayList&lt;String&gt;(new TextFile(&quot;SetOperations.java&quot;,&quot;\\W+&quot;));        Set&lt;String&gt; set=new TreeSet&lt;String&gt;(list);        for(String x:set){            ArrayList&lt;Integer&gt;ar=new ArrayList&lt;Integer&gt;();            for(int i=0;i&lt;list.size();i++){                if(x.equals(list.get(i))){                    ar.add(i);                }            }            map.put(x,ar);        }        System.out.println(&quot;map: &quot;+map);        System.out.println();        List&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt; list1=new ArrayList&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;(map.entrySet());        Collections.sort(list1,new Comparator&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;(){            @Override            public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2){            ArrayList ar1=(ArrayList)o1.getValue();            ArrayList ar2=(ArrayList)o2.getValue();            Integer aar1=(Integer)ar1.get(0);            Integer aar2=(Integer)ar2.get(0);            return aar1.compareTo(aar2);            }        });        System.out.println(&quot;list1: &quot;+list1);        System.out.println();        Map&lt;String,ArrayList&lt;Integer&gt;&gt;sortMap=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;();        for(Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; mapping:list1){            ArrayList ar3=(ArrayList)mapping.getValue();            sortMap.put(mapping.getKey(),ar3);        }        System.out.println(&quot;sortMap: &quot;+sortMap);    }}</code></pre><hr><h3 id="2-Map-Entry排序方法详解"><a href="#2-Map-Entry排序方法详解" class="headerlink" title="2. Map.Entry排序方法详解"></a>2. Map.Entry排序方法详解</h3><p>通过实例不难看出,使用这种方法(Map.Entry+Collections.sort())排序有三个步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">st=&gt;start: Start</span><br><span class="line">op1=&gt;operation: 创建储藏Map.Entry类对象的List(把对Map排序转化为对Collection排序)</span><br><span class="line">op2=&gt;operation: 重写Comparator中的compare()以实现各种个性化排序</span><br><span class="line">op3=&gt;operation: 创建LinkedListMap以储存排序后的Map</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-op1-&gt;op2-&gt;op3-&gt;e</span><br></pre></td></tr></table></figure><p>涉及到的东西有:Collections.sort(),Comparator.compare(),compareTo().<br><strong>Collections.sort()</strong>:</p><blockquote><p>sort<br>public static <t> void sort(List<t> list,Comparator&lt;? super T&gt; c)<br>    根据指定比较器产生的顺序对指定列表进行排序。此列表内的所有元素都必须可使用指定比较器 相互比较（也就是说，对于列表中的任意 e1 和 e2 元素， c.compare(e1, e2) 不得抛出 ClassCastException）。<br>    此排序被保证是稳定的：不会因调用 sort 而对相等的元素进行重新排序。<br>    排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n log(n) 性能。 指定列表必须是可修改的，但不必是可大小调整的。此实现将指定列表转储到一个数组中，并对数组进行排序，在重置数组中相应位置每个元素的列表上进行迭代。这避免了由于试图原地对链接列表进行排序而产生的 n2 log(n) 性能。<br>    参数：<br>        list - 要排序的列表。<br>        c - 确定列表顺序的比较器。 null 值指示应该使用元素的 自然顺序。<br>    抛出：<br>        ClassCastException - 如果列表中包含不可使用指定比较器 相互比较 的元素。<br>        UnsupportedOperationException - 如果指定列表的列表迭代器不支持 set 操作。</t></t></p></blockquote><p> 这是<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">Java API文档</a> 上查到的信息,我们可以看到Collections.sort()作用就是根据参数c(排序规则)对另一个参数list进行排序(其实实现Collections.sort()还有另外一种方法就是让类实现Comparable排序接口).那么排序规则呢?<br> <strong>Comparator.compare()</strong>:</p><blockquote><p> compare<br>int compare(T o1,T o2)<br>    比较用来排序的两个参数。根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。<br>    在前面的描述中，符号 sgn(expression) 表示 signum 数学函数，根据 expression 的值为负数、0 还是正数，该函数分别返回 -1、0 或 1。<br>    实现程序必须确保对于所有的 x 和 y 而言，都存在 sgn(compare(x, y)) == -sgn(compare(y, x))。（这意味着当且仅当 compare(y, x) 抛出异常时 compare(x, y) 才必须抛出异常。）<br>    实现程序还必须确保关系是可传递的：((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) 意味着 compare(x, z)&gt;0。<br>    最后，实现程序必须确保 compare(x, y)==0 意味着对于所有的 z 而言，都存在 sgn(compare(x, z))==sgn(compare(y, z))。<br>    虽然这种情况很普遍，但并不 严格要求 (compare(x, y)==0) == (x.equals(y))。一般说来，任何违背这个条件的 Comparator 都应该清楚地指出这一事实。推荐的语言是“注意：此 Comparator 强行进行与 equals 不一致的排序。”<br>    参数：<br>        o1 - 要比较的第一个对象。<br>        o2 - 要比较的第二个对象。<br>    返回：<br>        根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。<br>    抛出：<br>        ClassCastException - 如果参数的类型不允许此 Comparator 对它们进行比较。 </p></blockquote><p>我们使用的compare()是经过重写的,所以在这一步,我们可以自定义排序规则.在:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)</span></span>&#123;</span><br><span class="line">ArrayList ar1=(ArrayList)o1.getValue();</span><br><span class="line">ArrayList ar2=(ArrayList)o2.getValue();</span><br><span class="line">Integer aar1=(Integer)ar1.get(<span class="number">0</span>);</span><br><span class="line">Integer aar2=(Integer)ar2.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> aar1.compareTo(aar2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>中我们提取了Map的值(一个ArrayList<integer>)的第一项作为排序依据,在这一步,我们可以以其他依据来排序:</integer></p><ul><li><p><strong>按第二次出现的位置排序</strong>(遇到只出现过一次的单词会出错):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)</span></span>&#123;</span><br><span class="line">ArrayList ar1=(ArrayList)o1.getValue();</span><br><span class="line">ArrayList ar2=(ArrayList)o2.getValue();</span><br><span class="line">Integer aar1=(Integer)ar1.get(<span class="number">1</span>);<span class="comment">//原为(Integer)ar1.get(0)</span></span><br><span class="line">Integer aar2=(Integer)ar2.get(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> aar1.compareTo(aar2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>按键排序</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)</span></span>&#123;</span><br><span class="line">String s1=(String)o1.getKey();.getKey()获取键</span><br><span class="line">String s2=(String)o2.getKey(); </span><br><span class="line"><span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>(按键)倒序排序</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)</span></span>&#123;</span><br><span class="line">String s1=(String)o1.getKey();</span><br><span class="line">String s2=(String)o2.getKey(); </span><br><span class="line"><span class="keyword">return</span> s2.compareTo(s1);<span class="comment">//注意s1和s2的顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面每一种重写都包含了compareTo(),那么compareTo()方法是什么呢?</p><blockquote><p>compareTo<br>int compareTo(T o)<br>    比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。<br>    实现类必须确保对于所有的 x 和 y 都存在 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 的关系。（这意味着如果 y.compareTo(x) 抛出一个异常，则 x.compareTo(y) 也要抛出一个异常。）<br>    实现类还必须确保关系是可传递的：(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0) 意味着 x.compareTo(z)&gt;0。<br>    最后，实现者必须确保 x.compareTo(y)==0 意味着对于所有的 z，都存在 sgn(x.compareTo(z)) == sgn(y.compareTo(z))。 强烈推荐 (x.compareTo(y)==0) == (x.equals(y)) 这种做法，但并不是 严格要求这样做。一般来说，任何实现 Comparable 接口和违背此条件的类都应该清楚地指出这一事实。推荐如此阐述：“注意：此类具有与 equals 不一致的自然排序。”<br>    在前面的描述中，符号 sgn(expression) 指定 signum 数学函数，该函数根据 expression 的值是负数、零还是正数，分别返回 -1、0 或 1 中的一个值。<br>    参数：<br>    o - 要比较的对象。<br>    返回：<br>    负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。<br>    抛出：<br>    ClassCastException - 如果指定对象的类型不允许它与此对象进行比较。 </p></blockquote><h3 id="2-1-更简单的例子"><a href="#2-1-更简单的例子" class="headerlink" title="2.1 更简单的例子"></a>2.1 更简单的例子</h3><p>这个例子有些复杂,为了让这种排序法的思路更清晰,我们举以下例子:</p><blockquote><p>创建一个Map&lt;Character,Integer&gt;用以储存字母和其出现次数,对出现次数排序后输出这个Map.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">Random rand=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">Character x=(<span class="keyword">char</span>)(rand.nextInt(<span class="number">26</span>)+<span class="number">65</span>);</span><br><span class="line">Integer ints=map.get(x);</span><br><span class="line">map.put(x,ints==<span class="keyword">null</span>?<span class="number">1</span>:ints+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Character t:map.keySet())&#123;</span><br><span class="line">System.out.print(t+<span class="string">": "</span>+map.get(t)+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Character,Integer&gt;&gt;(map.entrySet());<span class="comment">//第一步,创建一个List&lt;Map.Entry&lt;String,List&lt;Integer&gt;&gt;&gt;</span></span><br><span class="line">Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123;<span class="comment">//第二步,用Collections.sort()对list排序(重写其compare()方法)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.getValue().compareTo(o2.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Map&lt;Character,Integer&gt; sortMap=<span class="keyword">new</span> LinkedHashMap&lt;Character,Integer&gt;();<span class="comment">//第三步,创建新的LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;以储存排序后的Map</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry me:list)</span><br><span class="line">sortMap.put((Character)me.getKey(),(Integer)me.getValue());</span><br><span class="line"><span class="keyword">for</span>(Character t:sortMap.keySet())&#123;</span><br><span class="line">System.out.print(t+<span class="string">": "</span>+sortMap.get(t)+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-对非基本类型排序"><a href="#2-2-对非基本类型排序" class="headerlink" title="2.2 对非基本类型排序"></a>2.2 对非基本类型排序</h3><p>compareTo()可以对基本类型进行比较进而实现排序,那么假如想对自定义类的对象进行排序该怎么办呢?一个可行的办法就是添加可以用来排序的指标,例子如下:</p><blockquote><p>自定义一个图书类,包含String域名字和作者,int域出版时间,float域价格.创建一系列图书对象添加到一个Map&lt;Integer,Book&gt;中,Integer表示图书的编号,依据图书各项属性排序并输出Map.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String author;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String n,String a,<span class="keyword">int</span> t,<span class="keyword">float</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=n;</span><br><span class="line"><span class="keyword">this</span>.author=a;</span><br><span class="line"><span class="keyword">this</span>.time=t;</span><br><span class="line"><span class="keyword">this</span>.price=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortName</span><span class="params">(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)</span></span>&#123;<span class="comment">//按书名排序</span></span><br><span class="line">Collections.sort(listk,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (o1.getValue().name).compareTo(o2.getValue().name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,Book&gt; x:listk)</span><br><span class="line">maptest.put(x.getKey(),x.getValue());</span><br><span class="line">System.out.println(<span class="string">"按书名排序:"</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer t:maptest.keySet())&#123;</span><br><span class="line">System.out.println(t+<span class="string">": "</span>+maptest.get(t).name+<span class="string">" "</span>+maptest.get(t).author+<span class="string">" "</span>+maptest.get(t).time+<span class="string">" "</span>+maptest.get(t).price);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">maptest.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortAuthor</span><span class="params">(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)</span></span>&#123;<span class="comment">//按作者排序</span></span><br><span class="line">Collections.sort(listk,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (o1.getValue().author).compareTo(o2.getValue().author);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,Book&gt; x:listk)</span><br><span class="line">maptest.put(x.getKey(),x.getValue());</span><br><span class="line">System.out.println(<span class="string">"按作者排序:"</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer t:maptest.keySet())&#123;</span><br><span class="line">System.out.println(t+<span class="string">": "</span>+maptest.get(t).name+<span class="string">" "</span>+maptest.get(t).author+<span class="string">" "</span>+maptest.get(t).time+<span class="string">" "</span>+maptest.get(t).price);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">maptest.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortTime</span><span class="params">(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)</span></span>&#123;<span class="comment">//按出版时间排序</span></span><br><span class="line">Collections.sort(listk,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)</span></span>&#123;<span class="comment">//int不能使用compareTo方法</span></span><br><span class="line">Integer i1=o1.getValue().time;</span><br><span class="line">Integer i2=o2.getValue().time;</span><br><span class="line"><span class="keyword">if</span>(i1&gt;i2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i1==i2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,Book&gt; x:listk)</span><br><span class="line">maptest.put(x.getKey(),x.getValue());</span><br><span class="line">System.out.println(<span class="string">"按出版时间排序:"</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer t:maptest.keySet())&#123;</span><br><span class="line">System.out.println(t+<span class="string">": "</span>+maptest.get(t).name+<span class="string">" "</span>+maptest.get(t).author+<span class="string">" "</span>+maptest.get(t).time+<span class="string">" "</span>+maptest.get(t).price);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">maptest.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortPrice</span><span class="params">(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)</span></span>&#123;<span class="comment">//按价格排序</span></span><br><span class="line">Collections.sort(listk,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)</span></span>&#123;<span class="comment">//float不能使用compareTo方法</span></span><br><span class="line">Float i1=o1.getValue().price;</span><br><span class="line">Float i2=o2.getValue().price;</span><br><span class="line"><span class="keyword">if</span>(i1&gt;i2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i1==i2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,Book&gt; x:listk)</span><br><span class="line">maptest.put(x.getKey(),x.getValue());</span><br><span class="line">System.out.println(<span class="string">"按价格排序:"</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer t:maptest.keySet())&#123;</span><br><span class="line">System.out.println(t+<span class="string">": "</span>+maptest.get(t).name+<span class="string">" "</span>+maptest.get(t).author+<span class="string">" "</span>+maptest.get(t).time+<span class="string">" "</span>+maptest.get(t).price);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">maptest.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Map&lt;Integer,Book&gt;map=<span class="keyword">new</span> HashMap&lt;Integer,Book&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="keyword">new</span> Book(<span class="string">"Java编程思想"</span>,<span class="string">"Bruce"</span>,<span class="number">2007</span>,<span class="number">108f</span>));</span><br><span class="line">map.put(<span class="number">2</span>,<span class="keyword">new</span> Book(<span class="string">"H黄金时代"</span>,<span class="string">"W王小波"</span>,<span class="number">1994</span>,<span class="number">68.9f</span>));</span><br><span class="line">map.put(<span class="number">3</span>,<span class="keyword">new</span> Book(<span class="string">"D东方故事集"</span>,<span class="string">"Y尤瑟纳尔"</span>,<span class="number">2007</span>,<span class="number">29.9f</span>));</span><br><span class="line">map.put(<span class="number">4</span>,<span class="keyword">new</span> Book(<span class="string">"D动物庄园"</span>,<span class="string">"Q乔治奥威尔"</span>,<span class="number">1945</span>,<span class="number">50f</span>));</span><br><span class="line">map.put(<span class="number">5</span>,<span class="keyword">new</span> Book(<span class="string">"C茶花女"</span>,<span class="string">"X小仲马"</span>,<span class="number">1848</span>,<span class="number">30f</span>));</span><br><span class="line">System.out.println(<span class="string">"原始顺序:"</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer t:map.keySet())&#123;</span><br><span class="line">System.out.println(t+<span class="string">": "</span>+map.get(t).name+<span class="string">" "</span>+map.get(t).author+<span class="string">" "</span>+map.get(t).time+<span class="string">" "</span>+map.get(t).price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">List&lt;Map.Entry&lt;Integer,Book&gt;&gt; list1=<span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer,Book&gt;&gt;(map.entrySet());</span><br><span class="line">Map&lt;Integer,Book&gt; sortMap=<span class="keyword">new</span> LinkedHashMap&lt;Integer,Book&gt;();</span><br><span class="line">sortName(list1,sortMap);</span><br><span class="line">sortAuthor(list1,sortMap);</span><br><span class="line">sortTime(list1,sortMap);</span><br><span class="line">sortPrice(list1,sortMap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-其他排序法"><a href="#3-其他排序法" class="headerlink" title="3. 其他排序法"></a>3. 其他排序法</h3>]]></content>
      
      
    </entry>
    
    <entry>
      <title>我不知道我不知道</title>
      <link href="/2018/08/03/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93/"/>
      <url>/2018/08/03/%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93/</url>
      <content type="html"><![CDATA[<p>硬盘出故障，买了块硬盘换了，重装系统后准备继续学习。突然发现之前建站的资料没有保存，所以一切从头开始吧。<br>重新下载配置文件，重新安装JDK，Git……一大堆需要安装的。好在我已经做过一次，大部分都轻车熟路过来了，少部分也在网上找到了解决办法。我不禁沾沾自喜，看来是个好的开始，接下来也会很顺利吧。<br>安装Notepad++，写完第一个题的答案，测试一下？<br>“嗯？为什么会识别不了javac指令？”<br>“我明明配置好环境了啊，还在CMD里看过。”<br>“再来看一看会不会是我没保存？嗯，并不是这个原因。”<br>“还是上网搜一搜吧”<br>“哦，原来是win10特殊，不能用相对路径，要输绝对路径才行”<br>“行吧”<br>改一改。可以用了。<br>“那么就开始做题吧”<br>“第一个——简单”<br>“第二个——easy”<br>“第三个——这题难不倒我”<br>“第四题——这题是什么意思？”<br>“容我再看看书”<br>……<br>“emmmm……怎么感觉好像没看过这个？”<br>“但是书上又有我做的标记？”<br>有点尴尬。<br>“不过还好我发现的及时，总比看完了觉得自己全掌握了被人指出来好多了吧。”<br>“嗯，那就开始看吧”<br>“什么？书上是这个意思？”<br>我算知道为什么我没读懂题了，我连这段精髓都没看进去怎么可能读得懂题。<br>“啊？还可以这样，真是厉害厉害”<br>……<br>以上就是我重新看书做题到现在的心路历程了，总是学到新东西，现在才知道当时以为是懂了的东西其实不懂，但不妨碍我当时因为觉得自己搞懂了而信心满满。<br>这大概就是学习新东西时最大的问题了吧，对于大的东西，比如说Java，我知道我不懂，但对于更具体的东西，比如我前面看过的章节，我不知道我不懂它们。有一件事和此类似，那就是提问，对于一个庞大的问题，有的人能够提出具体的关键性问题，让人知道他哪里懂了，哪里没懂，打算怎么解决，需要什么帮助。有的人却不知道该怎么提问，于是也得不到准确的答案。<br>不过反过来说，能及早发现问题也不失为一件好事。</p><p>今天做了些题，晚上打算写一篇博客，做一些看得到的东西。然后新建文章的时候又出错了，node不见了……进CMD查看，不出所料的不能识别，真是难受。只好上网搜一搜了，看了半天也没找到好办法，算了我还是重装吧。（于是“win10 line 2: node: command not found”这个问题又搁置了）。</p>]]></content>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello world</title>
      <link href="/2018/08/01/hello-world/"/>
      <url>/2018/08/01/hello-world/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
  
  
</search>
