<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM实现注册登录的demo]]></title>
    <url>%2F2018%2F11%2F29%2FSSM%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E7%9A%84demo%2F</url>
    <content type="text"><![CDATA[用SSM框架实现用户注册登录的demo 记录一下在Eclipse中创建一个SSM的过程。 搭建环境Java环境####安装JDK#### 要使用Java语言进行开发，首先需要安装Java。在官网 下载JDK安装。 注：注意区分JDK和JRE，前者是Java Development Kit，提供了Java的开发环境和运行环境，后者是Java Runtime Environment，只提供了运行环境。简单来说就是下图这样的关系： ####配置路径#### 右键此电脑选择属性，点击高级系统设置选择环境变量然后在系统变量下配置路径： 新建变量名 JAVA_HOME 变量值：C:\Program Files\Java\jdk-11（替换成自己的jdk安装路径） 新建变量名 Path 变量值：C:\Program Files\Java\jdk-11\bin;C:\Program Files\Java\jdk-11\jre\bin。注意Win10下一定不要用相对路径%JAVA_HOME%来代替它的值，否则过后用的时候可能不稳定（找不到Java）。 配置完毕后在命令行（Win+R后输入cmd回车）输入java -version查看版本信息，如果提示版本信息则安装成功。Eclipse、Tomcat、MySQL、springsource-tool-suite和（Maven） 安装配置Eclipse在Eclipse官网下载Eclipse按提示安装即可。需要设置Java的时候就添加之前安装好的Java。参考博客。 安装配置Tomcat参考链接 安装配置MySQL参考链接完成过后可安装一个简单的数据库工具SQLyog方便操作数据库 安装springsource-tool-suite参考博客 安装配置Maven 在官网下载maven； 配置环境变量： 新建变量名：MAVEN_HOME 变量值：D:\server\apache-maven-3.2.1（这是我的MAVEN路径） 编辑变量名：Path 在最前面加上：D:\server\apache-maven-3.2.1\bin;（注意，最后要有个”;”作为分隔符） 检查安装：按命令行输入mvn -version看是否提示版本信息，如果提示则安装成功。 SSMSSM简介 SSM指的是Spring+SpringMVC+Mybatis整合的框架。Spring依赖注入DI来管理各层的组件，使用面向切面编程AOP管理事物、日志、权限等。SpringMVC代表了Model(模型)View(视图)Controller(控制)接收外部请求,进行分发和处理。Mybatis是基于jdbc的框架,主要用来操作数据库,并且将业务实体和数据表联系起来。 服务器发送Http request请求，请求被前端控制器（DispatcherServlet）捕获。前端控制器根据xml文件中的配置（或者注解）对请求的URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用处理器映射器（HandlerMapping）获得处理该请求的Handler以及Handler对应的拦截器，最后以 HandlerExecutionChain 对象的形式返回。前端控制器根据获得的Handler，选择一个合适的处理器适配器（HandlerAdapter）去执行该Handler。处理器适配器提取request中的模型数据，填充Handler入参，执行处理器（Handler）（也称之为Controller）。Handler(Controller)执行完成后，向处理器适配器返回一个ModelAndView对象，处理器适配器再向前端控制器返回该ModelAndView对象（ModelAndView只是一个逻辑视图）。根据返回的ModelAndView，前端控制器请求一个适合的视图解析器（ViewResolver）（必须是已经注册到Spring容器中的ViewResolver）去进行视图解析，然后视图解析器向前端控制器返回一个真正的视图View（jsp）。 前端控制器通过Model解析出ModelAndView中的参数进行解析，最终展现出完整的View并通过Http response返回给客户端。（图片来自CSDN博客） 整合Spring+SpringMVC+MyBatis框架创建一个Project 点击“file” 选择“new” 点击“Project” 在”Wizards”中输入“maven”选择“maven project”点击“next” 新窗口选择workspace（这个project放在哪里）选择好后next 选择“maven-archetype-webapp”后点击next 输入项目信息都可以随便填，但是为了方便查找，Group id填自己的主页网址倒写比如个人首页是chaoxz2.github.io，那么这一项我就填io.github.chaoxz2。下一项Artifact id就填写项目名称，其他不用改，点击“finish”。 修改一些配置 在右边的Explorer栏点击倒三角形（鼠标悬停会提示View Menu），取消掉“.*resoureces”的勾选点确定。 现在Explorer栏中该项目下就有了”.setting”文件夹，在该文件夹下打开“org.eclipse.wst.common.component”文件，修改project-version=”1.5.0”为project-version=”1.6” 打开“org.eclipse.wst.common.project.facet.core.xml”将中的version值修改为3.0。 打开/helloworld（我的项目名）/src/main/webapp/WEB-INF下的web.xml文件，更改文件头。改为 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;/web-app&gt; 然后保存，右键项目名选择“properties”，再选择Project Facets,查看Java版本是否1.8和Dynamic Web Module是否为3.0然后apply and close。按Alt+F5刷新。这个项目初步设置就算完成了。（不报错） 添加依赖在demo0的项目视图里打开pom.xml文件引入依赖: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!-- 依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 表示开发的时候引入发布的时候不会加载 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 输入json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;demo0&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 编写配置文件在src/main/resources下新建四个文件：第一个:jdbc.properties用于配置连接池参数 jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/logintest?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false \#数据库用户名 jdbc.username=root \#数据库密码 jdbc.password=hello \#定义初始连接数 initialSize=0 \#定义最大连接数 maxActive=20 \#定义最大空闲 maxIdle=20 \#定义最大空闲 minIdle=1 \#定义最长等待时间 maxWait=60000 这部分可配置的参数取决于使用的连接池类型（此处使用DBCP）jdbc.driver部分注意根据安装的MySQL版本的不同配置不同的驱动：com.mysql.jdbc.Driver 是 mysql-connector-java 5中的;com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6中的。jdbc.url部分，可能出现时区问题编码问题等等问好过后的都是设置这些额外的东西的。（一般数据库连接出错都是这里的问题） 第二个log4j.properties用于配置日志相关参数 log4j.rootLogger=INFO,Console,File \#定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out \#可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n \#文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender \#指定输出目录 log4j.appender.File.File = logs/ssm.log \#定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB \# 输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d{yyyy-MM-dd HH\:mm\:ss}][%c]%m%n 第三个spring-mvc.xml用于配置SpringMVC相关设置 &lt;!-- 自动扫描该包，使springMVC认为包下使用了@Controller注解的类时控制器 --&gt; &lt;context:component-scan base-package=&quot;com.ssm.controller&quot;/&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;test/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动springMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后 --&gt; &lt;!--定义跳转文件的前后缀，试图模式配置 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; 第四个spring-mybatis.xml用于配置Spring和Mybatis &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.ssm&quot; /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/ssm/dao/IUserDao.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.ssm.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; 项目开始分析需求我们需要实现的是注册登录修改信息，那么需要一个实体类User，需要服务“注册”“登录”“修改信息”。 用户操作 Service名称 对应的数据库操作（Dao操作） 参数 注册 register 插入用户到表user User（全部注册信息） 登录 login 在表user中查找用户 User（包含邮箱和密码） 修改信息 updateUser 更新user User（id） 数据库建模对于用户，需要用id用于区分，通过邮箱注册需要字段邮箱，还需要有密码用于登录，最后还可以有一个昵称。所以user表内容如下： 列名 数据类型 长度 id BIGINT 20 email VARCHAR 25 name VARCHAR 25 password VARCHAR 25 此外id还应作为主键，非空，自增。 开始主要工作 顺序选择我们究竟该以什么顺序开始编写Java文件呢，从Entity到Dao到Service到Controller，还是刚好相反呢？对于这个简单的项目，以相反顺序能够减少Dao的编写工作量，只需要编写少量几个必须的方法即可。在我们使用未创建的Service和Dao时，Eclipse回提醒我们不存在，我们只需要点点鼠标创建就行，这样也能保证做的工作最少。 Controllercontroller实现数据和视图的交互，用户发起一次请求，controller调用对应的方法，在方法里和数据库交互，然后返回视图和数据。从用户角度来说，需要实现的效果是：123456789打开首页（Ⅰ）时，出现登录框和注册选项；点击“注册”按钮跳转到注册页面（Ⅱ）；在注册页面（Ⅱ）注册失败，返回注册页面（Ⅱ）；在注册页面（Ⅱ）注册成功，返回首页（Ⅰ）；在首页（Ⅰ）输入账号密码，登陆失败返回首页（Ⅰ）；在首页（Ⅰ）输入账号密码，登陆成功则跳转到个人信息页面（ⅲ）；在个人信息页面（ⅲ）点击“修改”跳转至修改个人信息页面（Ⅳ）；修改完成（无论成功失败），都跳转至个人信息页面（ⅲ）；点击个人信息页面（ⅲ）的“退出登录”后跳转至首页。 总共四个页面，对应需要controller做出的响应有： 123456在首页提交账号密码信息后，判断登录成功还是失败，返回相应数据和页面；（userLogin）点击“注册”按钮后返回注册页面；(register)在注册页面点击“验证邮箱是否可用”按钮后返回是否可用；（checkEmail）在注册页面提交注册信息后判断注册成功或者失败，返回相应页面；(userRegister)在个人信息页面，点击修改个人信息后返回修改个人信息页面；(update)提交修改信息后返回个人信息页面；(userUpdate) 所以Controller设计如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.ssm.controller;import java.util.HashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import com.mysql.cj.util.StringUtils;import com.ssm.entity.User;import com.ssm.service.IUserService;@Controllerpublic class UserController &#123; @Autowired private IUserService userservice; /* * 页面跳转 */ //到注册页面 @RequestMapping(value="register") public String toRegister(HttpServletRequest request) &#123; return "register"; &#125; //到登录页面 @RequestMapping(value = "login") public String toLogin(HttpServletRequest request)&#123; return "redirect:/login.jsp"; &#125; //到个人信息页面 @RequestMapping(value="userinfo") public String toMyinfo(HttpSession session,Model model,@ModelAttribute User user) &#123; return "userinfo"; &#125; //到更新信息页面 @RequestMapping(value="update") public String toUpdate(HttpServletRequest request) &#123; return "update"; &#125; //退出登录，注销账户 @RequestMapping(value = "UserLogout") public String logout(HttpSession session) &#123; session.invalidate(); return "redirect:/login.jsp"; &#125; /* * * 方法 */ //检查邮箱是否被注册 @RequestMapping(value="checkEmail",method = RequestMethod.POST) @ResponseBody public Map&lt;String,Object&gt; checkEmail(String email)&#123; if(StringUtils.isNullOrEmpty(email))&#123; System.out.println("用户名不能为空!"); return "redirect:/login.jsp"; &#125; Map&lt;String,Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); User user0=null; user0 = userservice.registerCheck(email); if(user0 == null)&#123; resultMap.put("result", "success"); return resultMap; &#125;else&#123; resultMap.put("result", "notsuccess"); return resultMap; &#125; &#125; //注册（在检查邮箱是否被注册中已经实现了这里的部分功能，相应部分可删去） @RequestMapping(value="userRegister",method = RequestMethod.POST) public String userRegister(@ModelAttribute User user) throws Exception&#123; try &#123; if(userservice.registerCheck(user.getEmail())==null) &#123; userservice.registerUser(user); //注册成功 System.out.println("注册成功返回登陆页"); return "redirect:/login.jsp"; &#125;else &#123; //用户已存在 System.out.println("注册失败返回注册页"); return "register"; &#125; &#125;catch(Exception e) &#123; System.out.println("出现错误，重新注册"); return "register"; &#125; &#125; //登录 @RequestMapping(value = "userLogin",method = RequestMethod.POST) public String userLogin(HttpSession session,@ModelAttribute User user)throws Exception &#123; try &#123; User user0=userservice.loginUser(user); if(user0!=null) &#123; //将用户保存在session里面 session.setAttribute("user",user0); return "userinfo"; &#125; else &#123; //邮箱或者密码错误 return "redirect:/login.jsp"; &#125; &#125;catch(Exception e) &#123; System.out.println("出现错误，返回登陆页"); return "redirect:/login.jsp"; &#125; &#125; //更新 @RequestMapping(value="userUpdate",method = RequestMethod.POST) @ResponseBody public Map&lt;String,Object&gt; updateUser(HttpSession session,@ModelAttribute User user)throws Exception &#123; userservice.updateUser(user); Map&lt;String,Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); if(!user.equals(session.getAttribute("user"))) &#123;//此处是判断新User是否和session中的User一样 //更新成功 session.setAttribute("user", user); System.out.println("更新成功"); resultMap.put("result", "success"); return resultMap; &#125;else &#123; resultMap.put("result", "notsuccess"); return resultMap; &#125; &#125; &#125; 相应的，新建controller里提到过的jsp文件和使用到的service方法。 ServiceService一般是创建一个Service接口，再创建它的实现类，刚刚在controller里“@Autowired”的就是一个接口。由Eclipse提醒我们创建的也是接口和抽象方法，不需要再更改，下面编写其实现类。 123456789101112131415161718192021222324252627282930313233343536package com.ssm.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.ssm.dao.IUserDao;import com.ssm.entity.User;import com.ssm.service.IUserService;@Servicepublic class UserServiceImpl implements IUserService&#123; @Autowired private IUserDao userdao; @Override public User registerCheck(String email) &#123; return userdao.findUserByEmail(email); &#125; @Override public User registerUser(User user) &#123; userdao.addUserByEmail(user); return userdao.findUserByEmailAndPassword(user); &#125; @Override public User loginUser(User user) &#123; User user0=userdao.findUserByEmailAndPassword(user); if(user0==null) return null; else return user0; &#125; @Override public void updateUser(User user) &#123; userdao.updateUser(user); &#125;&#125; 这一步我们又会创建Dao接口，下一步编写对应的xml文件。 Dao这里的Dao其实只需要编写xml文件即可，对应的Java文件在上一步中已经生成，注意两个文件名相同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.ssm.dao.IUserDao"&gt; &lt;!-- 查看邮箱是否已经注册 --&gt; &lt;select id="findUserByEmail" resultType="com.ssm.entity.User" parameterType="String" &gt; select *from user where email=#&#123;email&#125; &lt;/select&gt; &lt;!-- （通过邮箱）登录 --&gt; &lt;select id="findUserByEmailAndPassword" resultType="com.ssm.entity.User" parameterType="com.ssm.entity.User"&gt; select *from user where email=#&#123;email&#125; and password=#&#123;password&#125; &lt;/select&gt; &lt;!-- （用邮箱）注册 --&gt; &lt;insert id="addUserByEmail" parameterType="com.ssm.entity.User"&gt; insert into user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="name != null" &gt; name, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="email != null" &gt; email, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="name != null" &gt; #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null" &gt; #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;!-- 更改用户信息 --&gt; &lt;update id="updateUser" parameterType="com.ssm.entity.User" &gt; update user &lt;set &gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="name != null" &gt; name = #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null" &gt; email = #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=BIGINT&#125; &lt;/update&gt;&lt;/mapper&gt; Entity实体类只需要按照数据库设计好的字段设计即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.ssm.entity;public class User &#123; private Long id; private String email; private String name; private String password; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [id=" + id + ", email=" + email + ", name=" + name + ", password=" + password + "]"; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((email == null) ? 0 : email.hashCode()); result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((password == null) ? 0 : password.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; User other = (User) obj; if (email == null) &#123; if (other.email != null) return false; &#125; else if (!email.equals(other.email)) return false; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; if (password == null) &#123; if (other.password != null) return false; &#125; else if (!password.equals(other.password)) return false; return true; &#125;&#125; 注意：可以使用Mybatis-generator来自动生成model、Dao、Mapping文件。 jsp页面按照Controller设计中需要的页面编写即可。详细见Github测试测试数据库连接使用Eclipse自带工具测试数据库连接，参照博客做即可。Junit单元测试在前一步测试完数据库连接之后，可以使用Junit测试SSM项目各个模块是否有误。比如测试Dao时，右键点击UserDao.java依次“new”“other”搜索“junit test case”，选择后点击两次“next”，选择对全部方法进行测试后”finish”。具体测试文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.ssm.dao;import static org.junit.Assert.*;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.ssm.entity.User;@RunWith(SpringJUnit4ClassRunner.class) //使用junit4进行测试@ContextConfiguration(locations=&#123;"classpath:spring-mybatis.xml","classpath:spring-mvc.xml"&#125;)public class IUserDaoTest &#123; @Autowired private IUserDao userdao; @Test public void testFindUserByEmail() &#123; System.out.println("开始测试 FindUserByEmail"); User user =userdao.findUserByEmail("754");//数据库中包含该用户 if(user==null) System.out.println("FindUserByEmail测试未通过"); else System.out.println("FindUserByEmail测试通过"); &#125; @Test public void testAddUserByEmail() &#123; System.out.println("开始测试 AddUserByEmail"); User user =new User(); user.setEmail("dello"); user.setPassword("password"); userdao.addUserByEmail(user); User user1 = null; user1=userdao.findUserByEmail(user.getEmail())； if(user1==null) System.out.println("AddUserByEmail测试未通过"); else System.out.println("AddUserByEmail测试通过"); System.out.println(); &#125; @Test public void testFindUserByEmailAndPassword() &#123; System.out.println("开始测试 FindUserByEmailAndPassword"); User user=new User(); user.setEmail("890"); user.setPassword("zxcvb1");//账户是数据库中已有的 User user1 = userdao.findUserByEmailAndPassword(user）； if(user1==null) System.out.println("FindUserByEmailAndPassword测试未通过"); else System.out.println("FindUserByEmailAndPassword测试通过"); System.out.println(); &#125; @Test public void testUpdateUser() &#123; System.out.println("开始测试 UpdateUser"); User user=userdao.findUserByEmail("2533604553@qq.com"); user.setPassword("helloworld"); userdao.updateUser(user); System.out.println(userdao.findUserByEmail(user.getEmail())); &#125;&#125; 则可以测试Dao中所有方法，测试Service和这个一样，只不过使用“service”代替“userdao”，使用service中的方法代替dao中的方法。 Debug As…一切准备就绪后]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1. 不可变StringString对象时不可变的，String类中每一个看起来会修改String值的方法，是加上都是创建了一个全新的String对象，以包含修改过后的字符串内容，而最初的String对象则丝毫未动。示例 2. 重载“+”与StringBuilderString对象是不可变的，你可以给一个String对象添加任意多的别名。因为String对象具有只读特性，所以指向它的任何引用都不可能改变它的值，因此也就不会对其他的引用有什么影响。不可变性也带来了效率问题。为String对象重载的“+”就是一个例子。操作符“+”可以用来连接String：123456789public class Concatenation&#123; public static void main(String[] args)&#123; String mango="mango"; String s="abc"+mango+"def"+47; System.out.println(s); &#125;&#125;/*Output:abcmangodef47*/ 在这个例子里，编译器创建了一个StringBuilder对象用以构造最终的String，并且为每个字符串调用一次StringBuilder的append()方法。最后调用toString（）生成结果，并存为s。StringBuilder类的详细信息可参考Java在线API文档。为一个类编写toString()方法时，如果字符串操作比较简单，就信赖编译器。如果要在toString()中使用循环，那么最好自己创建一个StringBuilder对象，用它来构造最终结果。显式地创建StringBuilder对象可以使代码更简短，过程减少新的StringBuilder对象的创建，还可以指定大小，避免多次重新分配缓存。参考示例注意：使用append()方法时切勿在参数列表里使用“+”，否则编译器会创造新的StringBuilder对象来处理参数列表里的“+”。 3. 无意识的递归Java每个类从根本上都是继承自Object类，标准容易类也不例外，所以它们也有toString（）方法，并且覆写了该方法，使得它生成的结果能够表达容器自身和容器所包含的对象。例：123456789101112import java.util.*;public class ArrayListDisplay&#123; public static void main(String[] args)&#123; ArrayList&lt;Integer&gt; integers=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;10;i++) integers.add(i); System.out.println(integers); &#125;&#125;/*Output:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]*/ 假如希望toString()方法打印出对象的内存地址就会出错：1234567891011121314151617181920212223242526import java.util.*;public class InfiniteRecursion&#123; public String toString()&#123; return " InfiniteRecursion address: "+super.toString()+"\n";//!return " InfiniteRecursion address: "+this+"\n"; &#125; public static void main(String[] args)&#123; List&lt;InfiniteRecursion&gt; v=new ArrayList&lt;InfiniteRecursion&gt;(); for(int i=0;i&lt;10;i++) v.add(new InfiniteRecursion()); System.out.print(v); &#125;&#125;/*Output:[ InfiniteRecursion address: InfiniteRecursion@61064425, InfiniteRecursion address: InfiniteRecursion@d70c109, InfiniteRecursion address: InfiniteRecursion@17ed40e0, InfiniteRecursion address: InfiniteRecursion@50675690, InfiniteRecursion address: InfiniteRecursion@31b7dea0, InfiniteRecursion address: InfiniteRecursion@3ac42916, InfiniteRecursion address: InfiniteRecursion@47d384ee, InfiniteRecursion address: InfiniteRecursion@2d6a9952, InfiniteRecursion address: InfiniteRecursion@22a71081, InfiniteRecursion address: InfiniteRecursion@3930015a]*/ 当运行到&quot; InfiniteRecursion address: &quot;+this时就发生了自动转换，由InfiniteRecursion类型转换成了String类型：编译器看到String对象后跟着一个“+”，在后面的对象不是String，编译器试着将this转换成一个String。它怎么转换呢，正是通过调用this上的toString()方法，于是就发生了递归调用。所以如果真的想打印出对象的地址，应该调用Object.toString()方法。所以，不应该使用this,而应该调用super.toString()方法。（使用&quot; InfiniteRecursion address: &quot;+super.toString()而不是&quot; InfiniteRecursion address: &quot;+this） 4. String上的操作String对象具备的一些基本方法： 5. 格式化输出1. printf()使用特殊的占位符来表示数据将来的位置，将插入格式化字符串的参数以逗号分隔，排成一行。例如：1printf("Row1: [%d %f]\n",x,y); 2. System.out.format()format方法可用于PrintStream或PrintWriter对象，其中也包括System.out对象。（format()与printf()是等价的，需要一个格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符）。例：12345678910111213141516public class SimpleFormat&#123; public static void main(String[] args)&#123; int x=5; double y=5.332542; //the old way: System.out.println("Row 1: ["+x+" "+y+"]"); //the new way: System.out.format("Row 1: [%d %f]\n",x,y); //or: System.out.printf("Row 1: [%d %f]\n",x,y); &#125;&#125;/*Output:Row 1: [5 5.332542]Row 1: [5 5.332542]Row 1: [5 5.332542]*/ 3. Formatter类可以把Formatter看成一个翻译器，它将格式化字符串与数据翻译成需要的结果。当创建一个Formatter对象时，需要向其构造器传递一些信息，以告诉它最终的结果将向哪里输出，比如：1234567891011121314151617181920212223242526272829303132import java.util.*;import java.io.*;public class Turtle&#123; private String name; private Formatter f; public Turtle(String name,Formatter f)&#123; this.name=name; this.f=f; &#125; public void move(int x,int y)&#123; f.format("%s The Turtle is at (%d,%d)\n",name,x,y); &#125; public static void main(String[] args)&#123; PrintStream outAlias=System.out; Turtle tommy=new Turtle("Tommy",new Formatter(System.out)); Turtle terry=new Turtle("Terry",new Formatter(outAlias)); tommy.move(0,0); terry.move(4,8); tommy.move(3,4); tommy.move(2,5); tommy.move(3,3); tommy.move(3,3); &#125;&#125;/*Output:Tommy The Turtle is at (0,0)Terry The Turtle is at (4,8)Tommy The Turtle is at (3,4)Tommy The Turtle is at (2,5)Tommy The Turtle is at (3,3)Tommy The Turtle is at (3,3)*/ 中的123PrintStream outAlias=System.out;Turtle tommy=new Turtle("Tommy",new Formatter(System.out));Turtle terry=new Turtle("Terry",new Formatter(outAlias)); 4. 格式化说明符%[argument_index$][flags][width][.precision]conversion width指定域的最小尺寸（formatter对象通过在必要时添加空格，来确保至少达到一个长度，默认是右对齐，可以通过使用“-”来改变对齐方式），可用于各种类型的数据转换，行为方式一样。 precision用来指定最大尺寸。不是所有类型的数据都能使用它，应用于不同类型的数据转换时也有不同的意义: 将precision应用于String时，表示打印String时输出字符的最大数量； 将precision应用于浮点数时，表示小数部分要显示出来的位数（过多舍入，过少补零）； precision不能应用于整数。例： 123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Receipt&#123; private double total=0; private Formatter f=new Formatter(System.out); public void printTitle()&#123; f.format("%-15s %5s %10s\n","Item","Qty","Price"); f.format("%15s %5s %10s\n","----","---","-----"); &#125; public void print(String name,int qty,double price)&#123; f.format("%-15.15s %5d %10.2f\n",name,qty,price); total+=price; &#125; public void printTotal()&#123; f.format("%-15s %5s %10.2f\n","Tax","",total*0.06); f.format("%-15s %5s %10s\n","","","-----"); f.format("%-15s %5s %10.2f\n","Total","",total*1.06); &#125; public static void main(String[] args)&#123; Receipt receipt=new Receipt(); receipt.printTitle(); receipt.print("Jack's Magic Beans",4,4.25); receipt.print("Pricess Peas",3,5.1); receipt.print("Three Bears Porridge",1,14.29); receipt.printTotal(); &#125;&#125;/*Output:Item Qty Price ---- --- -----Jack's Magic Be 4 4.25Pricess Peas 3 5.10Three Bears Por 1 14.29Tax 1.42 -----Total 25.06*/ 令所有的宽度都由一个常量来控制，使宽度的改变更容易的简化程序。 5. Formatter转换常用类型转换：示例程序注意b转换，对于Boolean对象或者boolean基本类型，其转换结果使对应的true或false，但是，对其他类型的参数，只要不是null，转换的结果就永远是true。 6. String.format()方法String.format()是一个static方法，接受与Formatter.format()一样的参数，但返回一个String对象。例如：1234567891011121314public class DatabaseException extends Exception&#123; public DatabaseException(int transactionID,int queryID,String message)&#123; super(String.format("(t%d, q%d) %s", transactionID,queryID,message)); &#125; public static void main(String[] args)&#123; try&#123; throw new DatabaseException(3,7,"Write failed"); &#125;catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125;/*Output:DatabaseException: (t3, q7) Write failed*/ 其实在String.format（）内部，也是创建一个Formatter对象，然后将传入的参数传给这个Formatter。 6. 正则表达式1. 基础 查找一个数字： “\d” 查找一个或多个数字： “\d+” 查找一个前面带负号的数字：”-\d” 查找一个前面可能带负号的数字：”-?\d” 查找一个前面带正号或者负号的数字：”(-|\+)?\d”(“+”在正则表达式中有特殊含义，所以用\将其转义。使之称为表达式中的一个普通字符) String自带的三个正则表达式工具： matcher()方法：&quot;Hello World&quot;.matches(&quot;\\w+\\W\\w+&quot;) split()方法，功能是“将字符串从匹配正则表达式的地方切开”：&quot;Hello World&quot;.split(&quot; &quot;);详细示例。 “替换”，替换符合正则表达式的第一个地方或者所有匹配的地方：s.replaceFirst(&quot;f\\w+&quot;,&quot;hello&quot;)或者s.replaceAll(&quot;f\\w+&quot;,&quot;hello&quot;)详细示例。 2. 创建正则表达式字符： 字符 含义 字符 含义 B 自定字符B \n 换行符 \xhh 十六进制值为0xhh的字符 \r 回车 \uhhhh 十六进制表示为0xhhhh的Unicode字符 \f 换页 \t 制表符Tab \e 转义（Escape） 创建字符类的典型方式和一些预定义的类：字符类： 字符串 含义 字符串 含义 . 任意字符 \s 空白符（空格、tab、换行、换页和回车） [abc] 包含a、b和c的任何字符（a&#124;b&#124;c） \S 非空白符（[^\s]） [^abc] 除了a、b和c之外的任何字符（否定） \d 数字0-9 [a-zA-Z] 从a到z或者从A到Z的任何字符（范围） \D 非数字0-9[^0-9] [abc[hij]] 任意a、b、c、h、i和j字符（a&#124;b&#124;c&#124;h&#124;i&#124;j） \w 词字符[a-zA-Z0-9] [abc&amp;&amp;[hij]] 任意h、i或j（交） \W 非词字符[^\w] 部分常用表达式：逻辑操作符： 表达式 含义 XY Y跟在X后面 X&#124;Y X或者Y （X） 捕获组，可以在表达式中用\i引用第i个捕获组 匹配边界符： 表达式 含义 表达式 含义 ^ 一行的起始位置 \B 非词的边界 $ 一行的结束 \G 前一个匹配的结束 \b 词的边界 - - 3. 量词量词描述了一个模式吸收输入文本的方式： 贪婪型：量词总是贪婪的。贪婪表达式会为所有可能的模式发现尽可能多的匹配。 勉强型：用问好来指定：这个量词匹配满足模式所需的最少字符数。 占有型：目前只有在Java语言中可用。当正则表达式被应用于字符串时，会产生相当多的状态，以便在匹配失败时回溯。“占有型”量词不保存这些中间状态，以防止回溯。它们常常用于防止正则表达式失控。因此可以使正则表达式执行起来更有效。 贪婪型 勉强型 占有型 如何匹配 X? X?? X?+ 一个或者零个X X* X*? X*+ 零个或多个X X+ X+? X++ 一个或者多个X X{n} X{n}? X{n}+ 恰好n次X X{n,} X{n,}? X{n,}+ 至少n次X X{n,m} X{n,m}? X{n,m}+ X至少n次，且不超过m次 注意：为了防止歧义，表达式X通常用括号括起来。 4. Pattern和MatcherString类提供的正则表达式功能有限，所以我们需自己构造正则表达式对象，使用java.util.regex包可以实现这个目标： 首先，导入java.util.regex包。 第二步，使用static Pattern.compile()方法编译正则表达式。在这个过程中，它会根据String类型的正则表达式生成一个Pattern对象。 第三步，把想要检索的字符串传给Pattern对象的matcher()方法。matcher()方法会生成一个Matcher对象，它有很多功能可用（官方文档）。例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.regex.*;public class Test&#123; public static String s= "Hello world, he put up his hands and said "+ "I miss you, but I can't touch you, my love. "+ "now it's time to say goodbye to this world and say heelo wo you,"+ " I'm here."; public static void main(String[] args)&#123; Pattern p=Pattern.compile("\\w+"); Matcher m=p.matcher(s); while(m.find())&#123; System.out.println("Matcher() \""+m.group()+"\" start at: "+m.start()+" and end at: "+(m.end()-1)); &#125; &#125;&#125;/*Output:Matcher() "Hello" start at: 0 and end at: 4Matcher() "world" start at: 6 and end at: 10Matcher() "he" start at: 13 and end at: 14Matcher() "put" start at: 16 and end at: 18Matcher() "up" start at: 20 and end at: 21Matcher() "his" start at: 23 and end at: 25Matcher() "hands" start at: 27 and end at: 31Matcher() "and" start at: 33 and end at: 35Matcher() "said" start at: 37 and end at: 40Matcher() "I" start at: 42 and end at: 42Matcher() "miss" start at: 44 and end at: 47Matcher() "you" start at: 49 and end at: 51Matcher() "but" start at: 54 and end at: 56Matcher() "I" start at: 58 and end at: 58Matcher() "can" start at: 60 and end at: 62Matcher() "t" start at: 64 and end at: 64Matcher() "touch" start at: 66 and end at: 70Matcher() "you" start at: 72 and end at: 74Matcher() "my" start at: 77 and end at: 78Matcher() "love" start at: 80 and end at: 83Matcher() "now" start at: 86 and end at: 88Matcher() "it" start at: 90 and end at: 91Matcher() "s" start at: 93 and end at: 93Matcher() "time" start at: 95 and end at: 98Matcher() "to" start at: 100 and end at: 101Matcher() "say" start at: 103 and end at: 105Matcher() "goodbye" start at: 107 and end at: 113Matcher() "to" start at: 115 and end at: 116Matcher() "this" start at: 118 and end at: 121Matcher() "world" start at: 123 and end at: 127Matcher() "and" start at: 129 and end at: 131Matcher() "say" start at: 133 and end at: 135Matcher() "heelo" start at: 137 and end at: 141Matcher() "wo" start at: 143 and end at: 144Matcher() "you" start at: 146 and end at: 148Matcher() "I" start at: 151 and end at: 151Matcher() "m" start at: 153 and end at: 153Matcher() "here" start at: 155 and end at: 158*/ Matcher.find()方法可以用来在CharSequence中查找多个匹配，例如： 12345678910111213141516171819202122232425262728import java.util.regex.*;public class Test&#123; public static void main(String[] args)&#123; Pattern p=Pattern.compile("\\w+"); Matcher m=p.matcher("Evening is full of the linnet's wings"); while(m.find())&#123; System.out.println(m.group()+" start at: "+m.start()+" end at: "+(m.end()-1)); &#125; System.out.println(); int i=0; while(m.find(i))&#123; System.out.print(m.group()+" "); i++; &#125; &#125;&#125;/*Output:Evening start at: 0 end at: 6is start at: 8 end at: 9full start at: 11 end at: 14of start at: 16 end at: 17the start at: 19 end at: 21linnet start at: 23 end at: 28s start at: 30 end at: 30wings start at: 32 end at: 36Evening vening ening ning ing ng g is is s full full ull ll l of of f the the he e linnet linnet innet nnet net et t s s wings wings ings ngs gs s*/ 第一个find()像迭代器那样前向遍历输入字符串，第二个find()接收一个整数作为参数，该整数表示字符串中字符的位置，并以其作为搜索的起点。从结果可以看出，后裔版本的find()能根据其参数的值不断重新设定搜索的起始位置。 5. split()6. 替换操作7. reset()8. 正则表达式与java I/O7. 扫描输入8. StringTokenizer]]></content>
      <tags>
        <tag>字符串 String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过异常处理错误]]></title>
    <url>%2F2018%2F09%2F12%2F%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1. 异常异常是阻止当前方法或作用域继续执行的问题。在当前环境下无法获取必要的信息来解决问题，所做的只能是从当前环境跳出，把问题提交给上一级环境。这就是抛出异常时发生的事。当抛出异常后，有几件事随之发生： 首先，将使用new在堆上创建异常对象； 然后，当前执行路径被终止，并且从当前环境中弹出对异常对象的引用。此时异常处理机制接管程序，开始寻找一个恰当的地方（异常处理程序）将程序从错误中恢复，使程序换一种方式运行，或者继续运行下去。异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。异常允许我们强制程序停止运行，并告诉我们出现了什么问题，或者强制程序处理问题，回到稳定状态。 2. 捕获异常1. try块如果在方法内部抛出异常，这个方法将在抛出异常的过程中结束，要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里尝试各种方法调用，所以称为try块，是跟在try关键字后的普通程序块。例如：123try&#123; throw new Exception();&#125; 2. 异常处理抛出的异常必须在某处的到处理，处理它的地方就是异常处理程序，针对每个要捕获的异常，要准备相应的异常处理程序。异常处理程序紧跟在try块后面，以关键字catch表示。例如:12345try&#123; throw new Exception();&#125;catch(Exception e)&#123;System.out.println("Caught Exception: "+e);&#125; 那么，异常处理程序就能处理try块中抛出的Exception及其子类异常，处理方式是输出“Caught Exception: ”和具体异常名称。 3. 使用finally清理对于一些代码，可能会希望无论try块中是否抛出异常，它们都能得到执行。为了达到这个效果，可以在异常处理程序之后加上finally子句。例如：1234567try&#123; f();&#125;catch(Exception e)&#123; System.out.println("Caught Exception: "+e);&#125;finally&#123; System.out.println("Well Done!");&#125; 如果f()抛出Exception,异常被捕获，处理，然后执行finally内容，输出为：12Caught Exception: ExceptionWell Done! 如果f()不抛出异常，异常处理程序不被调用，执行finally内容,输出为：1Well Done! 即，无论try块是否抛出异常，finally子句都会被执行。因为涉及break和continue时finally子句也会得到执行。所以把finally子句和带标签的break和continue配合使用，可以取代goto。 1. finally用来做什么当要把除内存之外的资源恢复到它们的初始状态时，就需要用到finally子句。这种需要清理的资源可以是：已经打开的文件或者网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关。示例1更好的示例2，示例3。 2. 在return中使用finally因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作依旧会执行。示例 3. 异常丢失用某些特殊的方法使用finally子句，就会出现异常被忽略的情况。 未处理抛出的错误就在fnally子句里抛出新的异常4. 终止与恢复异常处理理论上有两种模型，一种是终止模型，一旦异常被抛出，不能回来继续执行；一种是恢复模型，异常处理程序修正错误，重新调用出问题的方法。Java支持终止模型，要想让Java实现类似恢复行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正错误。或者把try块放进while循环里，不断进入try块直到得到满意的结果。例如：12345678910111213141516171819202122232425public class Test&#123; static int counter; public static void main(String[] args)&#123; while(true)&#123; try&#123; if(counter++==0) throw new Exception(); System.out.println("No Exception"); &#125;catch(Exception e)&#123; System.out.println("Exception"); &#125;finally&#123; System.out.println("In finally clause"); if(counter==3) break; &#125; &#125; &#125;&#125;/*Output:ExceptionIn finally clauseNo ExceptionIn finally clauseNo ExceptionIn finally clause*/ 3. 自定义异常1. 创建自定义异常可以创建自定义异常来表示程序可能遇到的特定异常。但是新异常类型必须从已有的异常类继承，最好选择意思相近的异常类继承。-System.out和System.err:System.err将错误发送至标准错误流，不会被重定向；System.out也许会被重定向。 -printStackTrace():打印“从方法调用处直到异常抛出处”的方法调用序列； 2. 异常与记录日志通过添加或调用如下方法记录程序异常日志：1234567import java.util.logging.*; private static Loggerlogger=Logger.getLogger("LoggingException"); public LoggingException()&#123; StringWriter trace=new StringWriter(); printStackTrace(new PrintWriter(trace)); logger.severe(trace.toString());&#125; 例如，要让程序记录自身的异常日志,就需要在定义异常类的时候添加它：12345678910111213141516171819202122232425262728293031323334353637import java.util.logging.*;import java.io.*;class LoggingException extends Exception&#123; private static Logger logger=Logger.getLogger("LoggingException"); public LoggingException()&#123; StringWriter trace=new StringWriter(); printStackTrace(new PrintWriter(trace)); logger.severe(trace.toString()); &#125;&#125;public class LoggingExceptions&#123; public static void main(String[] args)&#123; try&#123; throw new LoggingException(); &#125;catch(LoggingException e)&#123; System.err.println("Caught "+e); &#125; try&#123; throw new LoggingException(); &#125;catch(LoggingException e)&#123; System.err.println("Caught "+e); &#125; &#125;&#125;/*Output:9月 13, 2018 10:49:29 上午 LoggingException &lt;init&gt;严重: LoggingException at LoggingExceptions.main(LoggingExceptions.java:16)Caught LoggingException9月 13, 2018 10:49:29 上午 LoggingException &lt;init&gt;严重: LoggingException at LoggingExceptions.main(LoggingExceptions.java:21)Caught LoggingException*/ 假如假如要捕获已有的代码的异常，就需要在异常处理中生成日志消息：12345678910111213141516171819202122import java.util.logging.*;import java.io.*;public class LoggingExceptions2&#123; private static Logger logger=Logger.getLogger("LoggerExceptions2"); static void logException(Exception e)&#123; StringWriter trace=new StringWriter(); e.printStackTrace(new PrintWriter(trace)); logger.severe(trace.toString()); &#125; public static void main(String[] args)&#123; try&#123; throw new NullPointerException(); &#125;catch(NullPointerException e)&#123; logException(e); &#125; &#125;&#125;/*Output:9月 13, 2018 10:53:21 上午 LoggingExceptions2 logException严重: java.lang.NullPointerException at LoggingExceptions2.main(LoggingExceptions2.java:13)*/ 核心就是在异常处理程序中调用一个方法，以异常为参数，输出日志。（不同于上一个例子，static void logException(Exception e)这里是以异常为参数的。）教材示例 4.异常说明异常说明使用了关键字throws，后面接一个所有潜在异常类型的列表。看起来像这样：void f() throws MyExceptionA,MyExceptionB{}如果没有异常说明如void f(){}就不能抛出任何异常(只有RuntimeException及其子类可以被抛出)。可以声明方法将抛出异常，但实际并不抛出。 5. 捕获所有异常可以只写一个异常处理程序来捕获所有异常，通过捕获异常类型的基类Exception就可以做到这一点。（最好放在处理程序列表的列尾，防止它抢在其他异常处理程序之前将异常捕获，得不到更加准确的关于异常的信息和处理） 1. 栈轨迹printStackTrace()提供的信息可以供getStackTrace()访问，这个方法将返回一个由栈轨迹中的元素（StackTraceElement）组成的数组，每一个元素都表示栈中的一帧。元素0是栈顶元素，并且是调用序列中的最后一个方法调用（这个Throwable被创建和抛出之处）。数组中最后一个元素和栈底是调用序列中的第一个方法调用。例：123456789101112131415161718192021222324public class Test&#123; static void f()&#123; try&#123; throw new Exception(); &#125;catch(Exception e)&#123; for(StackTraceElement ste:e.getStackTrace()) System.out.println(ste.getMethodName()); &#125; &#125; static void g()&#123; f(); &#125; static void h()&#123; g(); &#125; public static void main(String[] args)&#123; h(); &#125;&#125;/*Output:fghmain*/ 教材示例 2.重新抛出异常1. 抛出原异常重新抛出异常会把异常抛给上一级环境中的异常处理程序，同一个try块的后续catch子句将被忽略。此外，异常对象的所有信息都将得以保持，所以高一级捕获此异常的的异常处理程序可以从这个异常对象中得到所有信息。如果只是把当前异常对象重新抛出，printStackTrace()显示的是原来异常抛出点的调用栈信息，并非重新抛出点的信息。1234catch(Exception e)&#123; System.out.println("Anexception was thrown"); throw e;&#125; 要想更新这个信息，可以调用fillInStackTrace()，将返回一个Throwable对象，把当前调用栈信息填入原来的异常对象而建立。1234catch(Exception e)&#123; System.out.println("Anexception was thrown"); throw (Exception)e.fillInStackTrace();&#125; 教材示例 2.抛出新异常在捕获一场之后抛出新异常得到的效果类似于使用fillInStackTrace()，有关原异常点的信息会丢失，剩下的是与新抛出点有关的信息。教材示例 3. 异常链常常会想要在捕获一个异常后抛出另一个异常，并希望把原始的异常信息保存下来，这被称为异常链。现在所有的Throwable子类在构造器中都能接受一个cause对象作为参数。这个cause就用来表示原始异常，这样通过原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初的发生位置。在Throwable子类中，只有三种基本的异常类提供了带cause参数的构造器，它们是Error、Exception和RuntimeException。如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。教材示例简单示例如下：12345678910111213141516171819202122232425public class Test234&#123; public static void main(String[] args)&#123; try&#123; try&#123; throw new Exception(); &#125;catch(Exception e)&#123; System.out.println("Caught: "+e); e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;catch(RuntimeException ee)&#123; System.out.println("Caught: "+ee); ee.printStackTrace(); &#125; &#125;&#125;/*Output:Caught: java.lang.Exceptionjava.lang.Exception at Test234.main(Test234.java:5)Caught: java.lang.RuntimeException: java.lang.Exceptionjava.lang.RuntimeException: java.lang.Exception at Test234.main(Test234.java:9)Caused by: java.lang.Exception at Test234.main(Test234.java:5)*/ 6. Java标准异常Throwable这个Java类用来表示任何可以作为异常抛出的类。Throwable对象可以分成两种类型：Error用来表示编译时和系统错误：Exception是可以被抛出的基本类型。使用我们一般关心Exception类。特例：RuntimeException只能在代码中忽略RuntimeException（及其子类）类型的异常，其他类型异常的处理都是由编译器强制实施的。（简单说就是，异常声明只能忽略RuntimeException类和其子类，其他异常都必须说明） 7. 异常的限制当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。示例 构造器：父类构造器总会被子类构造器调用，所以子类构造器异常说明必须包含父类构造器的异常说明。 方法：父类方法f()声明异常MyExceptionF，子类方法f()不抛出异常父类方法g()声明异常MyExceptionG,子类方法g()抛出MyExceptionG的子类异常MyExceptionGA父类方法h()未声明异常MyExceptionH,子类方法h()抛出异常MyExceptionH//！错误子类新方法k()声明异常MyExceptionK 向上转型：要求捕获基类（和自身独有的异常）。 示例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import static com.goldfish666.util.Print.*;class MyExceptionA extends Exception&#123;&#125;class MyExceptionB extends Exception&#123;&#125;class MyExceptionG extends Exception&#123;&#125;class MyExceptionF extends Exception&#123;&#125;class MyExceptionH extends Exception&#123;&#125;class MyExceptionK extends Exception&#123;&#125;class MyExceptionGA extends MyExceptionG&#123;&#125;class Father&#123; public Father() throws MyExceptionA&#123;&#125; public static void f() throws MyExceptionF&#123;&#125; public static void g() throws MyExceptionG&#123;&#125; public static void h()&#123;&#125;&#125;public class Son extends Father&#123; public Son() throws MyExceptionA,MyExceptionB&#123;&#125; public static void f()&#123;&#125; public static void g() throws MyExceptionGA&#123;&#125; //!public static void h() throws MyExceptionH&#123;&#125; public static void k() throws MyExceptionK&#123;&#125; public static void main(String[] args)&#123; //方法 try&#123;//父类方法声明异常，子类方法不抛出 Son son=new Son(); f(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125; try&#123;//父类方法声明异常，子类方法抛出已声明异常的子类异常 Son son=new Son(); g(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125;catch(MyExceptionGA e)&#123; println("Caught MyExceptionGA"); &#125; try&#123;//父类方法不声明异常，子类方法抛出异常 Son son=new Son(); h(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125;/* catch(MyExceptionH e)&#123; println("Caught MyExceptionH"); &#125; */ try&#123;//子类新方法抛出异常 Son son=new Son(); k(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125;catch(MyExceptionK e)&#123; println("Caught MyExceptionK"); &#125; //向上转型 try&#123;//父类方法声明异常，子类方法不抛出 Father son=new Son(); f(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125; try&#123;//父类方法声明异常，子类方法抛出已声明异常的子类异常 Father son=new Son(); g(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125;catch(MyExceptionG e)&#123; println("Caught MyExceptionGA"); &#125; try&#123;//父类方法不声明异常，子类方法抛出异常 Father son=new Son(); h(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125; /*catch(MyExceptionH e)&#123; println("Caught MyExceptionH"); &#125; */ try&#123;//子类新方法抛出异常 Father son=new Son(); k(); &#125;catch(MyExceptionA e)&#123; println("Caught MyExceptionA"); &#125;catch(MyExceptionB e)&#123; println("Caught MyExceptionB"); &#125;catch(MyExceptionK e)&#123; println("Caught MyExceptionK"); &#125; &#125;&#125; 8. 构造器主要是构造过程中出现异常的处理，如果构造器在执行过程中半途而废，也许该对象的某些部分还没有被成功的创建，而这些部分在finally子句中却是要被清理的。对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class ConstractionException extends Exception&#123;&#125;class DisposeException extends Exception&#123;&#125;class Te&#123; private static long counter=1; private final long id; public Te()&#123;//构造器不会抛出异常 this.id=counter++; System.out.println("Te Constructor "+id); &#125; public void dispose()&#123; System.out.println("Te "+id+" disposed"); &#125;&#125;class Ae&#123; private static long counter=1; private final long id; public Ae() throws ConstractionException&#123;//构造器可能会抛出异常 this.id=counter++; System.out.println("Ae Constructor "+id); &#125; public void play()&#123; System.out.println("Good Job"); &#125; public void dispose()throws DisposeException&#123;//清理方法可能抛出异常 System.out.println("Ae "+id+" disposed"); &#125; public void dplay()&#123; System.out.println("Ae "+id+" dplay in finally"); &#125;&#125;public class Test24&#123; public static void main(String[] args)&#123;//构造器和清理方法都不会抛出异常： Te te1=new Te(); Te te2=new Te(); try&#123; &#125;finally&#123; te2.dispose(); te1.dispose(); &#125;//构造器和清理方法可能抛出异常： try&#123; Ae ae=new Ae(); try&#123; &#125;finally&#123; try&#123; ae.play(); //ae.dispose();1 //throw new DisposeException(); 2 &#125;catch(DisposeException e)&#123; System.out.println(e); &#125;finally&#123; ae.dplay(); &#125; &#125; &#125;catch(ConstractionException e)&#123; System.out.println(e); &#125; &#125;&#125;/*有1无2（清理方法未抛出异常）：Te Constructor 1Te Constructor 2Te 2 disposedTe 1 disposedAe Constructor 1Good JobAe 1 disposedDisposeExceptionAe 1 dplay in finally*//*有2无1（清理方法抛出异常）：Te Constructor 1Te Constructor 2Te 2 disposedTe 1 disposedAe Constructor 1Good JobAe 1 dplay in finally*/ 核心代码是嵌套的try块：1234567891011121314151617181920212223242526public class Construction&#123; public Construction() throws ConstructionException&#123; //...构造器描述 &#125; public void f() throws MethodException&#123; //...方法描述 &#125; public void disposeInFinally() &#123; //...清理方法 &#125; public static void main(String[] args)&#123; try&#123;//外层try块，如果构造过程抛出异常跳到25行的异常处理程序 Construction con=new Construction(); try&#123;//内层try块，在构造器成功完成构造后起作用 con.f();//既是为了实现程序的目标，也是为了最后用finally清理 &#125;catch(MethodException me)&#123; //...f()方法异常的异常处理程序 &#125;finally&#123; f.disposeInFinally();//清理对象con &#125; &#125; &#125;catch(ConstructionException ce)&#123; //...构造器异常的异常处理程序 &#125; &#125;&#125; 对于构造器可能抛出异常的构造过程，这样写可以应对所有情况：如果构造过程没有抛出异常，那么就继续对创建的对象进行操作，然后在finally子句里进行清理；如果构造过程抛出异常，那么程序会跳过之后的“对对象进行操作和清理”，直接转到构造器异常的异常处理程序。 9. 异常匹配抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序，找到匹配的处理程序之后，它就认为异常将得到处理，不再继续查找。（使用最近的匹配的异常处理程序处理异常）查找的时候并不要要求抛出的异常同异常处理程序声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。（不要求完全匹配，子类异常的对象可以被父类异常的异常处理程序捕获（匹配））例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class ExcepA extends Exception&#123;&#125;class ExcepAA extends ExcepA&#123;&#125;class ExcepAAA extends ExcepAA&#123;&#125;class A&#123; public void play()throws ExcepA&#123; throw new ExcepA(); &#125;&#125;class AA extends A&#123; public void play() throws ExcepAA&#123; throw new ExcepAA(); &#125;&#125;class AAA extends AA&#123; public void play() throws ExcepAAA&#123; throw new ExcepAAA(); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; A a=new AAA();//AAA a=new AAA()也可以，不过编译会有警告 try&#123; a.play(); &#125;catch(ExcepAAA x)&#123; System.out.println("Caught ExcepAAA"); &#125;catch(ExcepAA x)&#123; System.out.println("Caught ExcepAA"); &#125;catch(ExcepA x)&#123; System.out.println("Caught ExcepA"); &#125; try&#123; a.play(); &#125;catch(ExcepAA x)&#123; System.out.println("Caught ExcepAA"); &#125;catch(ExcepA x)&#123; System.out.println("Caught ExcepA"); &#125; try&#123; a.play(); &#125;catch(ExcepA x)&#123; System.out.println("Caught ExcepA"); &#125; &#125;&#125;/*Output:Caught ExcepAAACaught ExcepAACaught ExcepA*/ 10. 其他可选方式异常代表了当前方法不能继续执行的情况，开发异常处理的初衷是为了方便程序员处理错误。异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”，实际上异常处理的一个重要目标就是把错误处理的代码和错误发生的地点相分离。“被检查的异常”使这个问题变得有些复杂，它们强制你在没有准备好处理错误的时候加上catch子句，导致“harmful if swallowed”问题（无意间“吞食”了异常，导致异常丢失）。 1. 把异常传给控制台main()作为一个方法也可以有异常说明，声明可能抛出所有异常的父类Exception。通过把它传到控制台，就不必在main()里写try-catch子句了。例：12345678910111213class ExcepA extends Exception&#123;&#125;public class Testlee0&#123; public static void f() throws ExcepA&#123; throw new ExcepA(); &#125; public static void main(String[] args) throws Exception&#123; f(); &#125;&#125;/*Output:Exception in thread "main" ExcepA at Testlee0.f(Testlee0.java:4) at Testlee0.main(Testlee0.java:7)*/ 2. 把“被检查的异常”转换为“不检查的异常”从main()中抛出异常很方便，但是不是通用的方法，因为问题的实质是，当在一个普通方法里调用别的方法时，要考虑到“我不知道该怎么处理这个异常，但是也不想把它‘吞’了，或者打印一些无用的消息”。异常链给了一种思路来解决这个问题：把“被检查的异常”包装进RuntimeException里，这样就不必进行异常说明，也不用担心异常丢失，异常链还保证不会丢失任何原始异常的信息。 1. 对于系统自带的异常类： 抛出异常，异常处理程序里以该异常为参数抛出RuntimeException()构建异常链； 捕获RuntimeException异常，在它的异常处理程序里使用getCause()方法抛出异常； 尝试捕捉该异常，进行处理。例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546//对于已有的异常类import java.io.*;class Pack&#123; public void throwRuntimeException(int type)&#123; try&#123; switch(type)&#123; case 0: throw new IOException(); case 1:throw new FileNotFoundException(); case 2:throw new RuntimeException("Where am I"); default:return; &#125; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Pack pa=new Pack(); for(int i=0;i&lt;3;i++) try&#123; pa.throwRuntimeException(i); &#125;catch(RuntimeException re)&#123; try&#123; throw re.getCause(); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;catch(Throwable e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/*Output:java.io.IOException at Pack.throwRuntimeException(Test.java:6) at Test.main(Test.java:21)java.io.FileNotFoundException at Pack.throwRuntimeException(Test.java:7) at Test.main(Test.java:21)java.lang.RuntimeException: Where am I at Pack.throwRuntimeException(Test.java:8) at Test.main(Test.java:21)*/ 2. 对于自定义的异常类，让它继承自RuntimeException,甚至可以省去try-catch。例：12345678910111213class MyException extends RuntimeException&#123;&#125;public class Test&#123; public static void f()&#123; throw new MyException(); &#125; public static void main(String[] args)&#123; f(); &#125;&#125;/*Output:Exception in thread "main" MyException at Test.f(Test.java:5) at Test.main(Test.java:8)*/]]></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流程图测试]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[12graph TD Start --&gt; Stop]]></content>
  </entry>
  <entry>
    <title><![CDATA[Map的排序]]></title>
    <url>%2F2018%2F08%2F31%2FMap%E7%9A%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在对Map排序时学到了一种新的排序方式，那就是利用Map.Entry类和Collections.sort()方法排序。通过Map.Entry类创建一个能储存对应Map所有信息的ArrayList。把”对Map排序”问题转化为”对Collection排序”.参考链接 1. 实例在《Java编程思想（第四版）》持有对象这一章中，有这样一个题，要求按照值对Map排序： 26.拿到前一个练习中所产生的Map,并按照它们在最初的文件中出现的顺序重新创建单词顺序. 前一个题为: 25.创建一个Map&lt; String,List&lt; Integer&gt;&gt;,使用net.mindview.TextFile来打开一个文本文件,并一次读入一个单词(用”\W+”作为TextFile构造器的第二个参数).在读入单词时对它们进行计数,并且对于文件中的每一个单词,都在List中记录下与这个词相关联的单词计数.实际上,它记录的是该单词在文件中被发现的位置. 这样看来就是要创建一个Map&lt;String,List&lt;Integer&gt;&gt;,然后依据List&lt;Integer&gt;的第一项对Map排序.第25题代码如下:12345678910111213141516171819import java.util.*;import net.mindview.util.*;public class BackEx1125&#123; public static void main(String[] args)&#123; Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); List&lt;String&gt; list=new ArrayList&lt;String&gt;(new TextFile("SetOperations.java","\\W+")); Set&lt;String&gt; set=new TreeSet&lt;String&gt;(list); for(String x:set)&#123; ArrayList&lt;Integer&gt;ar=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;list.size();i++)&#123; if(x.equals(list.get(i)))&#123; ar.add(i); &#125; &#125; map.put(x,ar); &#125; System.out.print(map); &#125;&#125; 要在这个基础上以Map的值(List&lt;Integer&gt;)的第一项为依据排序,使用Map.Entry类和Collections.sort()方法排序的话就需要: 创建一个List&lt;Map.Entry&lt;String,List&lt;Integer&gt;&gt;&gt; list: 1List&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt; list1=new ArrayList&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;(map.entrySet()); 用Collections.sort()对list排序(重写其compare()方法); 12345678910Collections.sort(list1,new Comparator&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(0); Integer aar2=(Integer)ar2.get(0); return aar1.compareTo(aar2); &#125; &#125;); 创建新的LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;以储存排序后的Map: 12345Map&lt;String,ArrayList&lt;Integer&gt;&gt;sortMap=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); for(Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; mapping:list1)&#123; ArrayList ar3=(ArrayList)mapping.getValue(); sortMap.put(mapping.getKey(),ar3); &#125; 完整程序为:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import net.mindview.util.*;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.TreeMap;import java.util.*;public class BackEx1126&#123; public static void main(String[] args)&#123; Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); List&lt;String&gt; list=new ArrayList&lt;String&gt;(new TextFile("SetOperations.java","\\W+")); Set&lt;String&gt; set=new TreeSet&lt;String&gt;(list); for(String x:set)&#123; ArrayList&lt;Integer&gt;ar=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;list.size();i++)&#123; if(x.equals(list.get(i)))&#123; ar.add(i); &#125; &#125; map.put(x,ar); &#125; System.out.println("map: "+map); System.out.println(); List&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt; list1=new ArrayList&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;(map.entrySet()); Collections.sort(list1,new Comparator&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(0); Integer aar2=(Integer)ar2.get(0); return aar1.compareTo(aar2); &#125; &#125;); System.out.println("list1: "+list1); System.out.println(); Map&lt;String,ArrayList&lt;Integer&gt;&gt;sortMap=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); for(Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; mapping:list1)&#123; ArrayList ar3=(ArrayList)mapping.getValue(); sortMap.put(mapping.getKey(),ar3); &#125; System.out.println("sortMap: "+sortMap); &#125;&#125; 排序过程创建一个ArrayList，一个LinkedHashMap。 2. Map.Entry排序方法详解通过实例不难看出,使用这种方法(Map.Entry+Collections.sort())排序有三个步骤: 涉及到的东西有:Collections.sort(),Comparator.compare(),compareTo().Collections.sort(): sortpublic static void sort(List list,Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。此列表内的所有元素都必须可使用指定比较器 相互比较（也就是说，对于列表中的任意 e1 和 e2 元素， c.compare(e1, e2) 不得抛出 ClassCastException）。 此排序被保证是稳定的：不会因调用 sort 而对相等的元素进行重新排序。 排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n log(n) 性能。 指定列表必须是可修改的，但不必是可大小调整的。此实现将指定列表转储到一个数组中，并对数组进行排序，在重置数组中相应位置每个元素的列表上进行迭代。这避免了由于试图原地对链接列表进行排序而产生的 n2 log(n) 性能。 参数： list - 要排序的列表。 c - 确定列表顺序的比较器。 null 值指示应该使用元素的 自然顺序。 抛出： ClassCastException - 如果列表中包含不可使用指定比较器 相互比较 的元素。 UnsupportedOperationException - 如果指定列表的列表迭代器不支持 set 操作。 这是Java API文档 上查到的信息,我们可以看到Collections.sort()作用就是根据参数c(排序规则)对另一个参数list进行排序(其实实现Collections.sort()还有另外一种方法就是让类实现Comparable排序接口).那么排序规则呢? Comparator.compare(): compareint compare(T o1,T o2) 比较用来排序的两个参数。根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。 在前面的描述中，符号 sgn(expression) 表示 signum 数学函数，根据 expression 的值为负数、0 还是正数，该函数分别返回 -1、0 或 1。 实现程序必须确保对于所有的 x 和 y 而言，都存在 sgn(compare(x, y)) == -sgn(compare(y, x))。（这意味着当且仅当 compare(y, x) 抛出异常时 compare(x, y) 才必须抛出异常。） 实现程序还必须确保关系是可传递的：((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) 意味着 compare(x, z)&gt;0。 最后，实现程序必须确保 compare(x, y)==0 意味着对于所有的 z 而言，都存在 sgn(compare(x, z))==sgn(compare(y, z))。 虽然这种情况很普遍，但并不 严格要求 (compare(x, y)==0) == (x.equals(y))。一般说来，任何违背这个条件的 Comparator 都应该清楚地指出这一事实。推荐的语言是“注意：此 Comparator 强行进行与 equals 不一致的排序。” 参数： o1 - 要比较的第一个对象。 o2 - 要比较的第二个对象。 返回： 根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。 抛出： ClassCastException - 如果参数的类型不允许此 Comparator 对它们进行比较。 我们使用的compare()是经过重写的,所以在这一步,我们可以自定义排序规则.在:1234567public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(0); Integer aar2=(Integer)ar2.get(0); return aar1.compareTo(aar2); &#125; 中我们提取了Map的值(一个ArrayList&lt;Integer&gt;)的第一项作为排序依据,在这一步,我们可以以其他依据来排序: 按第二次出现的位置排序(遇到只出现过一次的单词会出错): 1234567public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(1);//原为(Integer)ar1.get(0) Integer aar2=(Integer)ar2.get(1); return aar1.compareTo(aar2); &#125; 按键排序: 12345public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; String s1=(String)o1.getKey();.getKey()获取键 String s2=(String)o2.getKey(); return s1.compareTo(s2); &#125; (按键)倒序排序 12345public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; String s1=(String)o1.getKey(); String s2=(String)o2.getKey(); return s2.compareTo(s1);//注意s1和s2的顺序 &#125; 上面每一种重写都包含了compareTo(),那么compareTo()方法是什么呢? compareToint compareTo(T o) 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 实现类必须确保对于所有的 x 和 y 都存在 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 的关系。（这意味着如果 y.compareTo(x) 抛出一个异常，则 x.compareTo(y) 也要抛出一个异常。） 实现类还必须确保关系是可传递的：(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0) 意味着 x.compareTo(z)&gt;0。 最后，实现者必须确保 x.compareTo(y)==0 意味着对于所有的 z，都存在 sgn(x.compareTo(z)) == sgn(y.compareTo(z))。 强烈推荐 (x.compareTo(y)==0) == (x.equals(y)) 这种做法，但并不是 严格要求这样做。一般来说，任何实现 Comparable 接口和违背此条件的类都应该清楚地指出这一事实。推荐如此阐述：“注意：此类具有与 equals 不一致的自然排序。” 在前面的描述中，符号 sgn(expression) 指定 signum 数学函数，该函数根据 expression 的值是负数、零还是正数，分别返回 -1、0 或 1 中的一个值。 参数： o - 要比较的对象。 返回： 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。 抛出： ClassCastException - 如果指定对象的类型不允许它与此对象进行比较。 2.1 更简单的例子这个例子有些复杂,为了让这种排序法的思路更清晰,我们举以下例子: 创建一个Map&lt;Character,Integer&gt;用以储存字母和其出现次数,对出现次数排序后输出这个Map. 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.util.Map.Entry;public class Test1&#123; public static void main(String[] args)&#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;(); Random rand=new Random(); for(int i=0;i&lt;1000;i++)&#123; Character x=(char)(rand.nextInt(26)+65); Integer ints=map.get(x); map.put(x,ints==null?1:ints+1); &#125; for(Character t:map.keySet())&#123; System.out.print(t+": "+map.get(t)+" "); &#125; System.out.println(); //排序 List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list=new ArrayList&lt;Map.Entry&lt;Character,Integer&gt;&gt;(map.entrySet());//第一步,创建一个List&lt;Map.Entry&lt;String,List&lt;Integer&gt;&gt;&gt; Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123;//第二步,用Collections.sort()对list排序(重写其compare()方法) @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); Map&lt;Character,Integer&gt; sortMap=new LinkedHashMap&lt;Character,Integer&gt;();//第三步,创建新的LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;以储存排序后的Map for(Map.Entry me:list) sortMap.put((Character)me.getKey(),(Integer)me.getValue()); for(Character t:sortMap.keySet())&#123; System.out.print(t+": "+sortMap.get(t)+" "); &#125; &#125;&#125; 2.2 对非基本类型排序compareTo()可以对基本类型进行比较进而实现排序,那么假如想对自定义类的对象进行排序该怎么办呢?一个可行的办法就是添加可以用来排序的指标,例子如下: 自定义一个图书类,包含String域名字和作者,int域出版时间,float域价格.创建一系列图书对象添加到一个Map&lt;Integer,Book&gt;中,Integer表示图书的编号,依据图书各项属性排序并输出Map. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.util.*;import java.util.Map.Entry;public class Book&#123; private String name; private String author; private int time; private float price; public Book(String n,String a,int t,float f)&#123; this.name=n; this.author=a; this.time=t; this.price=f; &#125; public static void sortName(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按书名排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123; return (o1.getValue().name).compareTo(o2.getValue().name); &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按书名排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void sortAuthor(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按作者排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123; return (o1.getValue().author).compareTo(o2.getValue().author); &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按作者排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void sortTime(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按出版时间排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123;//int不能使用compareTo方法 Integer i1=o1.getValue().time; Integer i2=o2.getValue().time; if(i1&gt;i2) return 1; else if(i1==i2) return 0; else return -1; &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按出版时间排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void sortPrice(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按价格排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123;//float不能使用compareTo方法 Float i1=o1.getValue().price; Float i2=o2.getValue().price; if(i1&gt;i2) return 1; else if(i1==i2) return 0; else return -1; &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按价格排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void main(String[] args)&#123; Map&lt;Integer,Book&gt;map=new HashMap&lt;Integer,Book&gt;(); map.put(1,new Book("Java编程思想","Bruce",2007,108f)); map.put(2,new Book("H黄金时代","W王小波",1994,68.9f)); map.put(3,new Book("D东方故事集","Y尤瑟纳尔",2007,29.9f)); map.put(4,new Book("D动物庄园","Q乔治奥威尔",1945,50f)); map.put(5,new Book("C茶花女","X小仲马",1848,30f)); System.out.println("原始顺序:"); for(Integer t:map.keySet())&#123; System.out.println(t+": "+map.get(t).name+" "+map.get(t).author+" "+map.get(t).time+" "+map.get(t).price); &#125; //排序 List&lt;Map.Entry&lt;Integer,Book&gt;&gt; list1=new ArrayList&lt;Map.Entry&lt;Integer,Book&gt;&gt;(map.entrySet()); Map&lt;Integer,Book&gt; sortMap=new LinkedHashMap&lt;Integer,Book&gt;(); sortName(list1,sortMap); sortAuthor(list1,sortMap); sortTime(list1,sortMap); sortPrice(list1,sortMap); &#125;&#125; 3. 其他排序法对于这个题，在了解到Map.Entry类和对值排序方法之前，我解题思路是这样的： 原来的Map是Map&lt;String,List&lt;Integer&gt;&gt;,名为map。第一步：新建一个TreeMap&lt;Integer,String&gt;名为map1，利用TreeMap的排序来实现排序。123Map&lt;Integer,String&gt; map1=new TreeMap&lt;Integer,String&gt;();for(String s:map.keySet()) map1.put(map.get(s).get(0),s); 第二步：创建一个LinkedHashMap&lt;String,List&lt;Integer&gt;&gt; sortMap（可按输入顺序输出Map)存储排好序的Map。 Map&lt;String,List&lt;Integer&gt;&gt; sortMap=new LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;; for(Integer i:map1.keySet()) sortMap.put(map1.get(i),map.get(map1.get(i))); 完整代码如下：123456789101112131415161718192021222324252627282930313233import net.mindview.util.*;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.TreeMap;import java.util.*;public class BackEx1126&#123; public static void main(String[] args)&#123; Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); List&lt;String&gt; list=new ArrayList&lt;String&gt;(new TextFile("SetOperations.java","\\W+")); Set&lt;String&gt; set=new TreeSet&lt;String&gt;(list); for(String x:set)&#123; ArrayList&lt;Integer&gt;ar=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;list.size();i++)&#123; if(x.equals(list.get(i)))&#123; ar.add(i); &#125; &#125; map.put(x,ar); &#125; System.out.println("map: "+map); System.out.println(); TreeMap&lt;Integer,String&gt; map1=new TreeMap&lt;Integer,String&gt;(); for(String s:map.keySet()) map1.put((Integer)map.get(s).get(0),s); Map&lt;String,List&lt;Integer&gt;&gt; sortMap=new LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;(); for(Integer i:map1.keySet()) sortMap.put(map1.get(i),map.get(map1.get(i))); System.out.println("排序后:"); System.out.println("sortMap: "+sortMap); &#125;&#125; 整个过程新建两个Map（一个TreeMap用于排序，一个LinkedHashMap用于按输入顺序输出）。遍历Map两次。这种方法能用的前提就是Map里每个键对应的值的第一项都不一样。只要有两个键对应值的第一项一样，那么在第一步创建TreeMap&lt;Integer,String&gt;map1后，向其添加元素的时候必然有键值对被覆盖，最后复原成LinkedHashMap&lt;String,List&lt;Integer&gt;也就会出问题。graph LR 创建List(把“对Map排序”转化为“对Collection排序”) --> 重写Comparator中的compare()（实现个性化排序方式); 重写Comparator中的compare()（实现个性化排序方式) --> 创建LinkedListMap（储存排好序的Map);{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2018%2F08%2F01%2Fhello-world%2F</url>
    <content type="text"></content>
  </entry>
</search>
