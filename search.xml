<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Map的排序]]></title>
    <url>%2F2018%2F08%2F31%2FMap%E7%9A%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在对Map排序时学到了一种新的排序方式，那就是利用Map.Entry类和Collections.sort()方法排序。通过Map.Entry类创建一个能储存对应Map所有信息的ArrayList。把”对Map排序”问题转化为”对Collection排序”.参考链接 1. 实例在《Java编程思想（第四版）》持有对象这一章中，有这样一个题，要求按照值对Map排序： 26.拿到前一个练习中所产生的Map,并按照它们在最初的文件中出现的顺序重新创建单词顺序. 前一个题为: 25.创建一个Map&lt; String,List&lt; Integer&gt;&gt;,使用net.mindview.TextFile来打开一个文本文件,并一次读入一个单词(用”\W+”作为TextFile构造器的第二个参数).在读入单词时对它们进行计数,并且对于文件中的每一个单词,都在List中记录下与这个词相关联的单词计数.实际上,它记录的是该单词在文件中被发现的位置. 这样看来就是要创建一个Map&lt;String,List&lt;Integer&gt;&gt;,然后依据List&lt;Integer&gt;的第一项对Map排序.第25题代码如下:12345678910111213141516171819import java.util.*;import net.mindview.util.*;public class BackEx1125&#123; public static void main(String[] args)&#123; Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); List&lt;String&gt; list=new ArrayList&lt;String&gt;(new TextFile("SetOperations.java","\\W+")); Set&lt;String&gt; set=new TreeSet&lt;String&gt;(list); for(String x:set)&#123; ArrayList&lt;Integer&gt;ar=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;list.size();i++)&#123; if(x.equals(list.get(i)))&#123; ar.add(i); &#125; &#125; map.put(x,ar); &#125; System.out.print(map); &#125;&#125; 要在这个基础上以Map的值(List&lt;Integer&gt;)的第一项为依据排序,使用Map.Entry类和Collections.sort()方法排序的话就需要: 创建一个List&lt;Map.Entry&lt;String,List&lt;Integer&gt;&gt;&gt; list: 1List&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt; list1=new ArrayList&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;(map.entrySet()); 用Collections.sort()对list排序(重写其compare()方法); 12345678910Collections.sort(list1,new Comparator&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(0); Integer aar2=(Integer)ar2.get(0); return aar1.compareTo(aar2); &#125; &#125;); 创建新的LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;以储存排序后的Map: 12345Map&lt;String,ArrayList&lt;Integer&gt;&gt;sortMap=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); for(Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; mapping:list1)&#123; ArrayList ar3=(ArrayList)mapping.getValue(); sortMap.put(mapping.getKey(),ar3); &#125; 完整程序为:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import net.mindview.util.*;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.TreeMap;import java.util.*;public class BackEx1126&#123; public static void main(String[] args)&#123; Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); List&lt;String&gt; list=new ArrayList&lt;String&gt;(new TextFile("SetOperations.java","\\W+")); Set&lt;String&gt; set=new TreeSet&lt;String&gt;(list); for(String x:set)&#123; ArrayList&lt;Integer&gt;ar=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;list.size();i++)&#123; if(x.equals(list.get(i)))&#123; ar.add(i); &#125; &#125; map.put(x,ar); &#125; System.out.println("map: "+map); System.out.println(); List&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt; list1=new ArrayList&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;(map.entrySet()); Collections.sort(list1,new Comparator&lt;Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(0); Integer aar2=(Integer)ar2.get(0); return aar1.compareTo(aar2); &#125; &#125;); System.out.println("list1: "+list1); System.out.println(); Map&lt;String,ArrayList&lt;Integer&gt;&gt;sortMap=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); for(Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; mapping:list1)&#123; ArrayList ar3=(ArrayList)mapping.getValue(); sortMap.put(mapping.getKey(),ar3); &#125; System.out.println("sortMap: "+sortMap); &#125;&#125; 排序过程创建一个ArrayList，一个LinkedHashMap。 2. Map.Entry排序方法详解通过实例不难看出,使用这种方法(Map.Entry+Collections.sort())排序有三个步骤: 12345678st=&gt;start: Starte=&gt;end: Endop1=&gt;operation: 创建List&lt;Map.Entry&gt;(把“对Map排序”转化为“对Collection排序”)op2=&gt;operation: 重写Comparator中的compare()（实现个性化排序方式）op3=&gt;operation: 创建LinkedListMap（储存排好序的Map）st-&gt;op1(right)-&gt;op2-&gt;op3-&gt;e 涉及到的东西有:Collections.sort(),Comparator.compare(),compareTo().Collections.sort(): sortpublic static void sort(List list,Comparator&lt;? super T&gt; c) 根据指定比较器产生的顺序对指定列表进行排序。此列表内的所有元素都必须可使用指定比较器 相互比较（也就是说，对于列表中的任意 e1 和 e2 元素， c.compare(e1, e2) 不得抛出 ClassCastException）。 此排序被保证是稳定的：不会因调用 sort 而对相等的元素进行重新排序。 排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n log(n) 性能。 指定列表必须是可修改的，但不必是可大小调整的。此实现将指定列表转储到一个数组中，并对数组进行排序，在重置数组中相应位置每个元素的列表上进行迭代。这避免了由于试图原地对链接列表进行排序而产生的 n2 log(n) 性能。 参数： list - 要排序的列表。 c - 确定列表顺序的比较器。 null 值指示应该使用元素的 自然顺序。 抛出： ClassCastException - 如果列表中包含不可使用指定比较器 相互比较 的元素。 UnsupportedOperationException - 如果指定列表的列表迭代器不支持 set 操作。 这是Java API文档 上查到的信息,我们可以看到Collections.sort()作用就是根据参数c(排序规则)对另一个参数list进行排序(其实实现Collections.sort()还有另外一种方法就是让类实现Comparable排序接口).那么排序规则呢? Comparator.compare(): compareint compare(T o1,T o2) 比较用来排序的两个参数。根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。 在前面的描述中，符号 sgn(expression) 表示 signum 数学函数，根据 expression 的值为负数、0 还是正数，该函数分别返回 -1、0 或 1。 实现程序必须确保对于所有的 x 和 y 而言，都存在 sgn(compare(x, y)) == -sgn(compare(y, x))。（这意味着当且仅当 compare(y, x) 抛出异常时 compare(x, y) 才必须抛出异常。） 实现程序还必须确保关系是可传递的：((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) 意味着 compare(x, z)&gt;0。 最后，实现程序必须确保 compare(x, y)==0 意味着对于所有的 z 而言，都存在 sgn(compare(x, z))==sgn(compare(y, z))。 虽然这种情况很普遍，但并不 严格要求 (compare(x, y)==0) == (x.equals(y))。一般说来，任何违背这个条件的 Comparator 都应该清楚地指出这一事实。推荐的语言是“注意：此 Comparator 强行进行与 equals 不一致的排序。” 参数： o1 - 要比较的第一个对象。 o2 - 要比较的第二个对象。 返回： 根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。 抛出： ClassCastException - 如果参数的类型不允许此 Comparator 对它们进行比较。 我们使用的compare()是经过重写的,所以在这一步,我们可以自定义排序规则.在:1234567public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(0); Integer aar2=(Integer)ar2.get(0); return aar1.compareTo(aar2); &#125; 中我们提取了Map的值(一个ArrayList&lt;Integer&gt;)的第一项作为排序依据,在这一步,我们可以以其他依据来排序: 按第二次出现的位置排序(遇到只出现过一次的单词会出错): 1234567public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; ArrayList ar1=(ArrayList)o1.getValue(); ArrayList ar2=(ArrayList)o2.getValue(); Integer aar1=(Integer)ar1.get(1);//原为(Integer)ar1.get(0) Integer aar2=(Integer)ar2.get(1); return aar1.compareTo(aar2); &#125; 按键排序: 12345public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; String s1=(String)o1.getKey();.getKey()获取键 String s2=(String)o2.getKey(); return s1.compareTo(s2); &#125; (按键)倒序排序 12345public int compare(Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o1,Entry&lt;String,ArrayList&lt;Integer&gt;&gt; o2)&#123; String s1=(String)o1.getKey(); String s2=(String)o2.getKey(); return s2.compareTo(s1);//注意s1和s2的顺序 &#125; 上面每一种重写都包含了compareTo(),那么compareTo()方法是什么呢? compareToint compareTo(T o) 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 实现类必须确保对于所有的 x 和 y 都存在 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 的关系。（这意味着如果 y.compareTo(x) 抛出一个异常，则 x.compareTo(y) 也要抛出一个异常。） 实现类还必须确保关系是可传递的：(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0) 意味着 x.compareTo(z)&gt;0。 最后，实现者必须确保 x.compareTo(y)==0 意味着对于所有的 z，都存在 sgn(x.compareTo(z)) == sgn(y.compareTo(z))。 强烈推荐 (x.compareTo(y)==0) == (x.equals(y)) 这种做法，但并不是 严格要求这样做。一般来说，任何实现 Comparable 接口和违背此条件的类都应该清楚地指出这一事实。推荐如此阐述：“注意：此类具有与 equals 不一致的自然排序。” 在前面的描述中，符号 sgn(expression) 指定 signum 数学函数，该函数根据 expression 的值是负数、零还是正数，分别返回 -1、0 或 1 中的一个值。 参数： o - 要比较的对象。 返回： 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。 抛出： ClassCastException - 如果指定对象的类型不允许它与此对象进行比较。 2.1 更简单的例子这个例子有些复杂,为了让这种排序法的思路更清晰,我们举以下例子: 创建一个Map&lt;Character,Integer&gt;用以储存字母和其出现次数,对出现次数排序后输出这个Map. 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.util.Map.Entry;public class Test1&#123; public static void main(String[] args)&#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;(); Random rand=new Random(); for(int i=0;i&lt;1000;i++)&#123; Character x=(char)(rand.nextInt(26)+65); Integer ints=map.get(x); map.put(x,ints==null?1:ints+1); &#125; for(Character t:map.keySet())&#123; System.out.print(t+": "+map.get(t)+" "); &#125; System.out.println(); //排序 List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list=new ArrayList&lt;Map.Entry&lt;Character,Integer&gt;&gt;(map.entrySet());//第一步,创建一个List&lt;Map.Entry&lt;String,List&lt;Integer&gt;&gt;&gt; Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123;//第二步,用Collections.sort()对list排序(重写其compare()方法) @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); Map&lt;Character,Integer&gt; sortMap=new LinkedHashMap&lt;Character,Integer&gt;();//第三步,创建新的LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;以储存排序后的Map for(Map.Entry me:list) sortMap.put((Character)me.getKey(),(Integer)me.getValue()); for(Character t:sortMap.keySet())&#123; System.out.print(t+": "+sortMap.get(t)+" "); &#125; &#125;&#125; 2.2 对非基本类型排序compareTo()可以对基本类型进行比较进而实现排序,那么假如想对自定义类的对象进行排序该怎么办呢?一个可行的办法就是添加可以用来排序的指标,例子如下: 自定义一个图书类,包含String域名字和作者,int域出版时间,float域价格.创建一系列图书对象添加到一个Map&lt;Integer,Book&gt;中,Integer表示图书的编号,依据图书各项属性排序并输出Map. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.util.*;import java.util.Map.Entry;public class Book&#123; private String name; private String author; private int time; private float price; public Book(String n,String a,int t,float f)&#123; this.name=n; this.author=a; this.time=t; this.price=f; &#125; public static void sortName(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按书名排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123; return (o1.getValue().name).compareTo(o2.getValue().name); &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按书名排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void sortAuthor(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按作者排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123; return (o1.getValue().author).compareTo(o2.getValue().author); &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按作者排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void sortTime(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按出版时间排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123;//int不能使用compareTo方法 Integer i1=o1.getValue().time; Integer i2=o2.getValue().time; if(i1&gt;i2) return 1; else if(i1==i2) return 0; else return -1; &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按出版时间排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void sortPrice(List&lt;Map.Entry&lt;Integer,Book&gt;&gt; listk,Map&lt;Integer,Book&gt; maptest)&#123;//按价格排序 Collections.sort(listk,new Comparator&lt;Map.Entry&lt;Integer,Book&gt;&gt;()&#123; @Override public int compare(Entry&lt;Integer,Book&gt; o1,Entry&lt;Integer,Book&gt; o2)&#123;//float不能使用compareTo方法 Float i1=o1.getValue().price; Float i2=o2.getValue().price; if(i1&gt;i2) return 1; else if(i1==i2) return 0; else return -1; &#125; &#125;); for(Map.Entry&lt;Integer,Book&gt; x:listk) maptest.put(x.getKey(),x.getValue()); System.out.println("按价格排序:"); for(Integer t:maptest.keySet())&#123; System.out.println(t+": "+maptest.get(t).name+" "+maptest.get(t).author+" "+maptest.get(t).time+" "+maptest.get(t).price); &#125; System.out.println(); maptest.clear(); &#125; public static void main(String[] args)&#123; Map&lt;Integer,Book&gt;map=new HashMap&lt;Integer,Book&gt;(); map.put(1,new Book("Java编程思想","Bruce",2007,108f)); map.put(2,new Book("H黄金时代","W王小波",1994,68.9f)); map.put(3,new Book("D东方故事集","Y尤瑟纳尔",2007,29.9f)); map.put(4,new Book("D动物庄园","Q乔治奥威尔",1945,50f)); map.put(5,new Book("C茶花女","X小仲马",1848,30f)); System.out.println("原始顺序:"); for(Integer t:map.keySet())&#123; System.out.println(t+": "+map.get(t).name+" "+map.get(t).author+" "+map.get(t).time+" "+map.get(t).price); &#125; //排序 List&lt;Map.Entry&lt;Integer,Book&gt;&gt; list1=new ArrayList&lt;Map.Entry&lt;Integer,Book&gt;&gt;(map.entrySet()); Map&lt;Integer,Book&gt; sortMap=new LinkedHashMap&lt;Integer,Book&gt;(); sortName(list1,sortMap); sortAuthor(list1,sortMap); sortTime(list1,sortMap); sortPrice(list1,sortMap); &#125;&#125; 3. 其他排序法对于这个题，在了解到Map.Entry类和对值排序方法之前，我解题思路是这样的： 原来的Map是Map&lt;String,List&lt;Integer&gt;&gt;,名为map。第一步：新建一个TreeMap&lt;Integer,String&gt;名为map1，利用TreeMap的排序来实现排序。123Map&lt;Integer,String&gt; map1=new TreeMap&lt;Integer,String&gt;();for(String s:map.keySet()) map1.put(map.get(s).get(0),s); 第二步：创建一个LinkedHashMap&lt;String,List&lt;Integer&gt;&gt; sortMap（可按输入顺序输出Map)存储排好序的Map。 Map&lt;String,List&lt;Integer&gt;&gt; sortMap=new LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;; for(Integer i:map1.keySet()) sortMap.put(map1.get(i),map.get(map1.get(i))); 完整代码如下：123456789101112131415161718192021222324252627282930313233import net.mindview.util.*;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.TreeMap;import java.util.*;public class BackEx1126&#123; public static void main(String[] args)&#123; Map&lt;String,ArrayList&lt;Integer&gt;&gt; map=new LinkedHashMap&lt;String,ArrayList&lt;Integer&gt;&gt;(); List&lt;String&gt; list=new ArrayList&lt;String&gt;(new TextFile("SetOperations.java","\\W+")); Set&lt;String&gt; set=new TreeSet&lt;String&gt;(list); for(String x:set)&#123; ArrayList&lt;Integer&gt;ar=new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;list.size();i++)&#123; if(x.equals(list.get(i)))&#123; ar.add(i); &#125; &#125; map.put(x,ar); &#125; System.out.println("map: "+map); System.out.println(); TreeMap&lt;Integer,String&gt; map1=new TreeMap&lt;Integer,String&gt;(); for(String s:map.keySet()) map1.put((Integer)map.get(s).get(0),s); Map&lt;String,List&lt;Integer&gt;&gt; sortMap=new LinkedHashMap&lt;String,List&lt;Integer&gt;&gt;(); for(Integer i:map1.keySet()) sortMap.put(map1.get(i),map.get(map1.get(i))); System.out.println("排序后:"); System.out.println("sortMap: "+sortMap); &#125;&#125; 整个过程新建两个Map（一个TreeMap用于排序，一个LinkedHashMap用于按输入顺序输出）。遍历Map两次。这种方法能用的前提就是Map里每个键对应的值的第一项都不一样。只要有两个键对应值的第一项一样，那么在第一步创建TreeMap&lt;Integer,String&gt;map1后，向其添加元素的时候必然有键值对被覆盖，最后复原成LinkedHashMap&lt;String,List&lt;Integer&gt;也就会出问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我不知道我不知道]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%2F</url>
    <content type="text"><![CDATA[硬盘出故障，买了块硬盘换了，重装系统后准备继续学习。突然发现之前建站的资料没有保存，所以一切从头开始吧。重新下载配置文件，重新安装JDK，Git……一大堆需要安装的。好在我已经做过一次，大部分都轻车熟路过来了，少部分也在网上找到了解决办法。我不禁沾沾自喜，看来是个好的开始，接下来也会很顺利吧。安装Notepad++，写完第一个题的答案，测试一下？“嗯？为什么会识别不了javac指令？”“我明明配置好环境了啊，还在CMD里看过。”“再来看一看会不会是我没保存？嗯，并不是这个原因。”“还是上网搜一搜吧”“哦，原来是win10特殊，不能用相对路径，要输绝对路径才行”“行吧”改一改。可以用了。“那么就开始做题吧”“第一个——简单”“第二个——easy”“第三个——这题难不倒我”“第四题——这题是什么意思？”“容我再看看书”……“emmmm……怎么感觉好像没看过这个？”“但是书上又有我做的标记？”有点尴尬。“不过还好我发现的及时，总比看完了觉得自己全掌握了被人指出来好多了吧。”“嗯，那就开始看吧”“什么？书上是这个意思？”我算知道为什么我没读懂题了，我连这段精髓都没看进去怎么可能读得懂题。“啊？还可以这样，真是厉害厉害”……以上就是我重新看书做题到现在的心路历程了，总是学到新东西，现在才知道当时以为是懂了的东西其实不懂，但不妨碍我当时因为觉得自己搞懂了而信心满满。这大概就是学习新东西时最大的问题了吧，对于大的东西，比如说Java，我知道我不懂，但对于更具体的东西，比如我前面看过的章节，我不知道我不懂它们。有一件事和此类似，那就是提问，对于一个庞大的问题，有的人能够提出具体的关键性问题，让人知道他哪里懂了，哪里没懂，打算怎么解决，需要什么帮助。有的人却不知道该怎么提问，于是也得不到准确的答案。不过反过来说，能及早发现问题也不失为一件好事。 今天做了些题，晚上打算写一篇博客，做一些看得到的东西。然后新建文章的时候又出错了，node不见了……进CMD查看，不出所料的不能识别，真是难受。只好上网搜一搜了，看了半天也没找到好办法，算了我还是重装吧。（于是“win10 line 2: node: command not found”这个问题又搁置了）。]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2018%2F08%2F01%2Fhello-world%2F</url>
    <content type="text"></content>
  </entry>
</search>
